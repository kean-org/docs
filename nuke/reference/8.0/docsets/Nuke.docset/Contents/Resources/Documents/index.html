<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Nuke  Reference</title>
    <link rel="stylesheet" type="text/css" href="css/jazzy.css" />
    <link rel="stylesheet" type="text/css" href="css/highlight.css" />
    <meta charset='utf-8'>
    <script src="js/jquery.min.js" defer></script>
    <script src="js/jazzy.js" defer></script>
    
  </head>
  <body>
    <a title="Nuke  Reference"></a>
    <header>
      <div class="content-wrapper">
        <p><a href="index.html">Nuke Docs</a> (70% documented)</p>
      </div>
    </header>
    <div class="content-wrapper">
      <p id="breadcrumbs">
        <a href="index.html">Nuke Reference</a>
        <img id="carat" src="img/carat.png" />
        Nuke  Reference
      </p>
    </div>
    <div class="content-wrapper">
      <nav class="sidebar">
        <ul class="nav-groups">
          <li class="nav-group-name">
            <a href="Classes.html">Classes</a>
            <ul class="nav-group-tasks">
              <li class="nav-group-task">
                <a href="Classes/DataCache.html">DataCache</a>
              </li>
              <li class="nav-group-task">
                <a href="Classes/DataLoader.html">DataLoader</a>
              </li>
              <li class="nav-group-task">
                <a href="Classes/DataLoader/Error.html">– Error</a>
              </li>
              <li class="nav-group-task">
                <a href="Classes/ImageCache.html">ImageCache</a>
              </li>
              <li class="nav-group-task">
                <a href="Classes/ImageDecoder.html">ImageDecoder</a>
              </li>
              <li class="nav-group-task">
                <a href="Classes/ImageDecoderRegistry.html">ImageDecoderRegistry</a>
              </li>
              <li class="nav-group-task">
                <a href="Classes/ImagePipeline.html">ImagePipeline</a>
              </li>
              <li class="nav-group-task">
                <a href="Classes/ImagePipeline/Error.html">– Error</a>
              </li>
              <li class="nav-group-task">
                <a href="Classes/ImagePipeline/Configuration.html">– Configuration</a>
              </li>
              <li class="nav-group-task">
                <a href="Classes/ImagePreheater.html">ImagePreheater</a>
              </li>
              <li class="nav-group-task">
                <a href="Classes/ImagePreheater/Destination.html">– Destination</a>
              </li>
              <li class="nav-group-task">
                <a href="Classes/ImageResponse.html">ImageResponse</a>
              </li>
              <li class="nav-group-task">
                <a href="Classes/ImageTask.html">ImageTask</a>
              </li>
            </ul>
          </li>
          <li class="nav-group-name">
            <a href="Enums.html">Enumerations</a>
            <ul class="nav-group-tasks">
              <li class="nav-group-task">
                <a href="Enums/ImageProcessor.html">ImageProcessor</a>
              </li>
              <li class="nav-group-task">
                <a href="Enums/ImageProcessor/Unit.html">– Unit</a>
              </li>
              <li class="nav-group-task">
                <a href="Enums/ImageProcessor/Resize.html">– Resize</a>
              </li>
              <li class="nav-group-task">
                <a href="Enums/ImageProcessor/Composition.html">– Composition</a>
              </li>
              <li class="nav-group-task">
                <a href="Enums/ImageProcessor/Anonymous.html">– Anonymous</a>
              </li>
            </ul>
          </li>
          <li class="nav-group-name">
            <a href="Extensions.html">Extensions</a>
            <ul class="nav-group-tasks">
              <li class="nav-group-task">
                <a href="Extensions/CGSize.html">CGSize</a>
              </li>
              <li class="nav-group-task">
                <a href="Extensions/Image.html">Image</a>
              </li>
              <li class="nav-group-task">
                <a href="Extensions/ImageProcessor.html">ImageProcessor</a>
              </li>
              <li class="nav-group-task">
                <a href="Extensions/ImageProcessor/Circle.html">– Circle</a>
              </li>
              <li class="nav-group-task">
                <a href="Extensions/ImageProcessor/RoundedCorners.html">– RoundedCorners</a>
              </li>
              <li class="nav-group-task">
                <a href="Extensions/ImageProcessor/CoreImageFilter.html">– CoreImageFilter</a>
              </li>
              <li class="nav-group-task">
                <a href="Extensions/ImageProcessor/GaussianBlur.html">– GaussianBlur</a>
              </li>
              <li class="nav-group-task">
                <a href="Extensions/NSImageView.html">NSImageView</a>
              </li>
              <li class="nav-group-task">
                <a href="Extensions/UIImageView.html">UIImageView</a>
              </li>
              <li class="nav-group-task">
                <a href="Extensions/WKInterfaceImage.html">WKInterfaceImage</a>
              </li>
            </ul>
          </li>
          <li class="nav-group-name">
            <a href="Functions.html">Functions</a>
            <ul class="nav-group-tasks">
              <li class="nav-group-task">
                <a href="Functions.html#/s:4Nuke13cancelRequest3foryAA0A16_ImageDisplaying_So6NSViewCXc_tF">cancelRequest(for:)</a>
              </li>
              <li class="nav-group-task">
                <a href="Functions.html#/s:4Nuke9loadImage4with7options4into8progress10completionAA0C4TaskCSg10Foundation3URLV_AA0C14LoadingOptionsVAA0a1_C10Displaying_So6NSViewCXcyAA0C8ResponseCSg_s5Int64VAWtcSgys6ResultOyAtA0C8PipelineC5ErrorOGcSgtF">loadImage(with:options:into:progress:completion:)</a>
              </li>
              <li class="nav-group-task">
                <a href="Functions.html#/s:4Nuke9loadImage4with7options4into8progress10completionAA0C4TaskCSgAA0C7RequestV_AA0C14LoadingOptionsVAA0a1_C10Displaying_So6NSViewCXcyAA0C8ResponseCSg_s5Int64VAVtcSgys6ResultOyAsA0C8PipelineC5ErrorOGcSgtF">loadImage(with:options:into:progress:completion:)</a>
              </li>
            </ul>
          </li>
          <li class="nav-group-name">
            <a href="Protocols.html">Protocols</a>
            <ul class="nav-group-tasks">
              <li class="nav-group-task">
                <a href="Protocols/Cancellable.html">Cancellable</a>
              </li>
              <li class="nav-group-task">
                <a href="Protocols/DataCaching.html">DataCaching</a>
              </li>
              <li class="nav-group-task">
                <a href="Protocols/DataLoading.html">DataLoading</a>
              </li>
              <li class="nav-group-task">
                <a href="Protocols/ImageCaching.html">ImageCaching</a>
              </li>
              <li class="nav-group-task">
                <a href="Protocols/ImageDecoding.html">ImageDecoding</a>
              </li>
              <li class="nav-group-task">
                <a href="Protocols/ImageEncoding.html">ImageEncoding</a>
              </li>
              <li class="nav-group-task">
                <a href="Protocols/ImageProcessing.html">ImageProcessing</a>
              </li>
              <li class="nav-group-task">
                <a href="Protocols/Nuke_ImageDisplaying.html">Nuke_ImageDisplaying</a>
              </li>
            </ul>
          </li>
          <li class="nav-group-name">
            <a href="Structs.html">Structures</a>
            <ul class="nav-group-tasks">
              <li class="nav-group-task">
                <a href="Structs.html#/s:4Nuke17AnyImageProcessorV">AnyImageProcessor</a>
              </li>
              <li class="nav-group-task">
                <a href="Structs/ImageDecodingContext.html">ImageDecodingContext</a>
              </li>
              <li class="nav-group-task">
                <a href="Structs/ImageEncoder.html">ImageEncoder</a>
              </li>
              <li class="nav-group-task">
                <a href="Structs/ImageEncodingContext.html">ImageEncodingContext</a>
              </li>
              <li class="nav-group-task">
                <a href="Structs/ImageLoadingOptions.html">ImageLoadingOptions</a>
              </li>
              <li class="nav-group-task">
                <a href="Structs/ImageLoadingOptions/ContentModes.html">– ContentModes</a>
              </li>
              <li class="nav-group-task">
                <a href="Structs/ImageLoadingOptions/Transition.html">– Transition</a>
              </li>
              <li class="nav-group-task">
                <a href="Structs/ImageProcessingContext.html">ImageProcessingContext</a>
              </li>
              <li class="nav-group-task">
                <a href="Structs/ImageRequest.html">ImageRequest</a>
              </li>
              <li class="nav-group-task">
                <a href="Structs/ImageRequest/Priority.html">– Priority</a>
              </li>
              <li class="nav-group-task">
                <a href="Structs/ImageRequestOptions.html">ImageRequestOptions</a>
              </li>
              <li class="nav-group-task">
                <a href="Structs/ImageRequestOptions/MemoryCacheOptions.html">– MemoryCacheOptions</a>
              </li>
              <li class="nav-group-task">
                <a href="Structs/ImageTaskMetrics.html">ImageTaskMetrics</a>
              </li>
              <li class="nav-group-task">
                <a href="Structs/ImageTaskMetrics/SessionMetrics.html">– SessionMetrics</a>
              </li>
            </ul>
          </li>
          <li class="nav-group-name">
            <a href="Typealiases.html">Type Aliases</a>
            <ul class="nav-group-tasks">
              <li class="nav-group-task">
                <a href="Typealiases.html#/Image">Image</a>
              </li>
              <li class="nav-group-task">
                <a href="Typealiases.html#/s:4Nuke5Imagea">Image</a>
              </li>
              <li class="nav-group-task">
                <a href="Typealiases.html#/ImageDisplayingView">ImageDisplayingView</a>
              </li>
              <li class="nav-group-task">
                <a href="Typealiases.html#/s:4Nuke19ImageDisplayingViewa">ImageDisplayingView</a>
              </li>
            </ul>
          </li>
        </ul>
      </nav>
      <article class="main-content">
        <section>
          <section class="section">
            
            <p><br/></p>

<p align="left"><img src="https://cloud.githubusercontent.com/assets/1567433/13918338/f8670eea-ef7f-11e5-814d-f15bdfd6b2c0.png" height="180"/>

# Powerful Image Loading System

<p align="left">
<img src="https://img.shields.io/cocoapods/v/Nuke.svg?label=version">
<img src="https://img.shields.io/badge/platforms-iOS%2C%20macOS%2C%20watchOS%2C%20tvOS-lightgrey.svg">
<img src="https://img.shields.io/badge/test%20coverage-100%25-brightgreen.svg">
<a href="https://travis-ci.org/kean/Nuke"><img src="https://img.shields.io/travis/kean/Nuke/master.svg"></a>
</p>

<blockquote>
<p>Upgrading from the previous version? Use a <a href="https://github.com/kean/Nuke/blob/master/Documentation/Migrations"><strong>Migration Guide</strong></a>.</p>
</blockquote>

<p>Nuke provides a simple and efficient way to download and display images in your app. Behind its clear and concise API is an advanced architecture which enables its unique features and offers virtually unlimited possibilities for customization.</p>

<blockquote>
<p><strong>Fast LRU memory and disk cache</strong> · <strong>Smart background decompression</strong> · <strong>Image processing</strong> · <strong>Resumable downloads</strong> · <strong>Intelligent deduplication</strong> · <strong>Request prioritization</strong> · <strong>Prefetching</strong> · <strong>Rate limiting</strong> · <strong>Progressive JPEG, WebP</strong> · <strong>Animated images</strong> · <strong>Alamofire, WebP, Gifu, FLAnimatedImage integrations</strong> · <strong>Reactive extensions</strong></p>
</blockquote>

<p><br/></p>
<h2 id='getting-started' class='heading'>Getting Started</h2>

<p>Nuke is easy to learn and use. Here is an overview of its APIs and features:</p>

<ul>
<li><strong>Image View Extensions</strong> ‣ <a href="#image-view-extensions">Load and Display Image</a> | <a href="#placeholders-transitions-content-modes">Placeholders, Transitions, Content Modes</a> | <a href="#imagerequest"><code><a href="Structs/ImageRequest.html">ImageRequest</a></code></a></li>
<li><strong>Image Processing</strong> ‣ <a href="#resize"><code>Resize</code></a> | <a href="#gaussianblur-core-image"><code>GaussianBlur</code>, Core Image</a> | <a href="#custom-processors">Custom Processors</a> | <a href="#smart-decompression">Smart Decompression</a></li>
<li><strong>Image Pipeline</strong> ‣ <a href="#image-pipeline">Load Image</a> | <a href="#imagetask"><code><a href="Classes/ImageTask.html">ImageTask</a></code></a> | <a href="#customize-image-pipeline">Customize Image Pipeline</a> | <a href="#default-image-pipeline">Default Pipeline</a></li>
<li><strong>Caching</strong> ‣ <a href="#lru-memory-cache">LRU Memory Cache</a> | <a href="#http-disk-cache">HTTP Disk Cache</a> | <a href="#aggressive-lru-disk-cache">Aggressive LRU Disk Cache</a></li>
<li><strong>Advanced Features</strong> ‣ <a href="#image-preheating">Preheat Images</a> | <a href="#progressive-decoding">Progressive Decoding</a> | <a href="#animated-images">Animated Images</a> | <a href="#webp">WebP</a> | <a href="#rxnuke">RxNuke</a></li>
</ul>

<p>To learn more see a full <a href="https://kean.github.io/Nuke/reference/7.3/index.html"><strong>API Reference</strong></a>, and check out the demo project included in the repository. When you are ready to install, follow the <a href="https://github.com/kean/Nuke/blob/master/Documentation/Guides/Installation%20Guide.md"><strong>Installation Guide</strong></a>. See <a href="#h_requirements"><strong>Requirements</strong></a> for a list of supported platforms.</p>

<p>To learn about the image pipeline itself, see the dedicated section:</p>

<ul>
<li><strong>Image Pipeline</strong> ‣ <a href="#h_design">Overview</a> | <a href="#data-loading-and-caching">Data Loading and Caching</a> | <a href="#resumable-downloads">Resumable Downloads</a> | <a href="#memory-cache">Memory Cache</a> | <a href="#deduplication">Deduplication</a> | <a href="#performance">Performance</a> | <a href="#h_plugins">Extensions</a></li>
</ul>

<p>If you&rsquo;d like to contribute to Nuke see <a href="#h_contribute"><strong>Contributing</strong></a>.</p>

<p><br/></p>
<h1 id='image-view-extensions' class='heading'>Image View Extensions</h1>

<p><img align="right" src="https://user-images.githubusercontent.com/1567433/59150381-d34beb80-8a22-11e9-8d9a-6b1527ffc9e1.png" width="360"/></p>

<p>Download and display an image in an image view with a single line of code:</p>
<pre class="highlight swift"><code><span class="kt">Nuke</span><span class="o">.</span><span class="nf">loadImage</span><span class="p">(</span><span class="nv">with</span><span class="p">:</span> <span class="n">url</span><span class="p">,</span> <span class="nv">into</span><span class="p">:</span> <span class="n">imageView</span><span class="p">)</span>
</code></pre>

<p>Nuke will check if the image exists in the memory cache, and if it does, will instantly display it. If not, the image data will be loaded, decoded, processed, and decompressed in the background.</p>

<blockquote>
<p>See <a href="#h_design">Image Pipeline Overview</a> to learn more.</p>
</blockquote>
<h3 id='in-a-list' class='heading'>In a List</h3>

<p>When you request a new image for the existing view, Nuke will prepare it for reuse and cancel any outstanding requests for the view, making it extremely easy to manages images in lists.</p>
<pre class="highlight swift"><code><span class="kd">func</span> <span class="nf">collectionView</span><span class="p">(</span><span class="n">_</span> <span class="nv">collectionView</span><span class="p">:</span> <span class="kt">UICollectionView</span><span class="p">,</span>
                    <span class="n">cellForItemAt</span> <span class="nv">indexPath</span><span class="p">:</span> <span class="kt">IndexPath</span><span class="p">)</span>
                    <span class="o">-&gt;</span> <span class="kt">UICollectionViewCell</span> <span class="p">{</span>
    <span class="kt">Nuke</span><span class="o">.</span><span class="nf">loadImage</span><span class="p">(</span><span class="nv">with</span><span class="p">:</span> <span class="n">url</span><span class="p">,</span> <span class="nv">into</span><span class="p">:</span> <span class="n">cell</span><span class="o">.</span><span class="n">imageView</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>

<blockquote>
<p>The requests also get canceled automatically when the views are deallocated. Call <code>Nuke.cancelRequest(for: imageView)</code> to cancel the request manually.</p>
</blockquote>
<h3 id='placeholders-transitions-content-modes' class='heading'>Placeholders, Transitions, Content Modes</h3>

<p>Use <code><a href="Structs/ImageLoadingOptions.html">ImageLoadingOptions</a></code> to set a <code>placeholder</code>, select one of the built-in <code>transitions</code>, or provide a custom one.</p>
<pre class="highlight swift"><code><span class="k">let</span> <span class="nv">options</span> <span class="o">=</span> <span class="kt">ImageLoadingOptions</span><span class="p">(</span>
    <span class="nv">placeholder</span><span class="p">:</span> <span class="kt">UIImage</span><span class="p">(</span><span class="nv">named</span><span class="p">:</span> <span class="s">"placeholder"</span><span class="p">),</span>
    <span class="nv">transition</span><span class="p">:</span> <span class="o">.</span><span class="nf">fadeIn</span><span class="p">(</span><span class="nv">duration</span><span class="p">:</span> <span class="mf">0.33</span><span class="p">)</span>
<span class="p">)</span>
<span class="kt">Nuke</span><span class="o">.</span><span class="nf">loadImage</span><span class="p">(</span><span class="nv">with</span><span class="p">:</span> <span class="n">url</span><span class="p">,</span> <span class="nv">options</span><span class="p">:</span> <span class="n">options</span><span class="p">,</span> <span class="nv">into</span><span class="p">:</span> <span class="n">imageView</span><span class="p">)</span>
</code></pre>

<p>You can even customize content modes per image type:</p>
<pre class="highlight swift"><code><span class="k">let</span> <span class="nv">options</span> <span class="o">=</span> <span class="kt">ImageLoadingOptions</span><span class="p">(</span>
    <span class="nv">placeholder</span><span class="p">:</span> <span class="kt">UIImage</span><span class="p">(</span><span class="nv">named</span><span class="p">:</span> <span class="s">"placeholder"</span><span class="p">),</span>
    <span class="nv">failureImage</span><span class="p">:</span> <span class="kt">UIImage</span><span class="p">(</span><span class="nv">named</span><span class="p">:</span> <span class="s">"failureImage"</span><span class="p">),</span>
    <span class="nv">contentModes</span><span class="p">:</span> <span class="o">.</span><span class="nf">init</span><span class="p">(</span><span class="nv">success</span><span class="p">:</span> <span class="o">.</span><span class="n">scaleAspectFill</span><span class="p">,</span> <span class="nv">failure</span><span class="p">:</span> <span class="o">.</span><span class="n">center</span><span class="p">,</span> <span class="nv">placeholder</span><span class="p">:</span> <span class="o">.</span><span class="n">center</span><span class="p">)</span>
<span class="p">)</span>
</code></pre>

<blockquote>
<p>In case you want all image views to have the same behavior, you can modify <code><a href="Structs/ImageLoadingOptions.html#/s:4Nuke19ImageLoadingOptionsV6sharedACvpZ">ImageLoadingOptions.shared</a></code>.</p>
</blockquote>
<h3 id='code-imagerequest-code' class='heading'><code><a href="Structs/ImageRequest.html">ImageRequest</a></code></h3>

<p><code><a href="Structs/ImageRequest.html">ImageRequest</a></code> allows you to set image processors, change the request priority and more:</p>
<pre class="highlight swift"><code><span class="k">let</span> <span class="nv">request</span> <span class="o">=</span> <span class="kt">ImageRequest</span><span class="p">(</span>
    <span class="nv">url</span><span class="p">:</span> <span class="kt">URL</span><span class="p">(</span><span class="nv">string</span><span class="p">:</span> <span class="s">"http://..."</span><span class="p">),</span>
    <span class="nv">processors</span><span class="p">:</span> <span class="p">[</span><span class="kt">ImageProcessor</span><span class="o">.</span><span class="kt">Resize</span><span class="p">(</span><span class="nv">size</span><span class="p">:</span> <span class="n">imageView</span><span class="o">.</span><span class="n">bounds</span><span class="o">.</span><span class="n">size</span><span class="p">)],</span>
    <span class="nv">priority</span><span class="p">:</span> <span class="o">.</span><span class="n">high</span>
<span class="p">)</span>
</code></pre>

<p>The advanced options available via <code><a href="Structs/ImageRequestOptions.html">ImageRequestOptions</a></code>. For example, you can provide a <code>filteredURL</code> to be used as a key for caching in case the URL contains transient query parameters.</p>
<pre class="highlight swift"><code><span class="k">let</span> <span class="nv">request</span> <span class="o">=</span> <span class="kt">ImageRequest</span><span class="p">(</span>
    <span class="nv">url</span><span class="p">:</span> <span class="kt">URL</span><span class="p">(</span><span class="nv">string</span><span class="p">:</span> <span class="s">"http://example.com/image.jpeg?token=123"</span><span class="p">)</span><span class="o">!</span><span class="p">,</span>
    <span class="nv">options</span><span class="p">:</span> <span class="kt">ImageRequestOptions</span><span class="p">(</span>
        <span class="nv">filteredURL</span><span class="p">:</span> <span class="s">"http://example.com/image.jpeg"</span>
    <span class="p">)</span>
<span class="p">)</span>
</code></pre>

<blockquote>
<p>There are more options available, to see all of them check the inline documentation for <code><a href="Structs/ImageRequestOptions.html">ImageRequestOptions</a></code>.</p>
</blockquote>

<p><br/></p>
<h1 id='image-processing' class='heading'>Image Processing</h1>

<p><img align="right" src="https://user-images.githubusercontent.com/1567433/59151404-cb944300-8a32-11e9-9c58-dbed9789080f.png" width="360"/></p>

<p>Nuke features a powerful and efficient image processing infrastructure with multiple built-in processors including <code><a href="Enums/ImageProcessor/Resize.html">ImageProcessor.Resize</a></code>, <code>.Circle</code>, <code>.RoundedCorners</code>, <code>.CoreImageFilter</code>, <code>.GaussianBlur</code>.</p>

<blockquote>
<p>This and other screenshots are from the demo project included in the repo.</p>
</blockquote>
<h3 id='code-resize-code' class='heading'><code>Resize</code></h3>

<p>To resize an image, use <code><a href="Enums/ImageProcessor/Resize.html">ImageProcessor.Resize</a></code>:</p>
<pre class="highlight swift"><code><span class="kt">ImageRequest</span><span class="p">(</span><span class="nv">url</span><span class="p">:</span> <span class="n">url</span><span class="p">,</span> <span class="nv">processors</span><span class="p">:</span> <span class="p">[</span>
    <span class="kt">ImageProcessor</span><span class="o">.</span><span class="kt">Resize</span><span class="p">(</span><span class="nv">size</span><span class="p">:</span> <span class="n">imageView</span><span class="o">.</span><span class="n">bounds</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
<span class="p">])</span>
</code></pre>

<p>By default, the target size is in points. When the image is loaded, Nuke will scale it to fill the target area maintaining the aspect ratio. To crop the image set <code>crop</code> to <code>true</code>.</p>

<blockquote>
<p>There are a few other options available, see <code><a href="Enums/ImageProcessor/Resize.html">ImageProcessor.Resize</a></code> documentation for more info.</p>
</blockquote>
<h3 id='code-gaussianblur-code-core-image' class='heading'><code>GaussianBlur</code>, Core Image</h3>

<p><code>ImageProcessor.GaussianBlur</code> blurs the input image. It is powered by the native <code>CoreImage</code> framework. To apply other filters, use <code>ImageProcessor.CoreImageFilter</code>:</p>
<pre class="highlight swift"><code><span class="kt">ImageProcessor</span><span class="o">.</span><span class="kt">CoreImageFilter</span><span class="p">(</span><span class="nv">name</span><span class="p">:</span> <span class="s">"CISepiaTone"</span><span class="p">)</span>
</code></pre>

<blockquote>
<p>For a complete list of Core Image filters see <a href="https://developer.apple.com/library/archive/documentation/GraphicsImaging/Reference/CoreImageFilterReference/index.html">Core Image Filter Reference</a>.</p>
</blockquote>
<h3 id='custom-processors' class='heading'>Custom Processors</h3>

<p>Custom processors need to conform to <code><a href="Protocols/ImageProcessing.html">ImageProcessing</a></code> protocol:</p>
<pre class="highlight swift"><code><span class="kd">public</span> <span class="kd">protocol</span> <span class="kt">ImageProcessing</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">identifier</span><span class="p">:</span> <span class="kt">String</span> <span class="p">{</span> <span class="k">get</span> <span class="p">}</span>
    <span class="k">var</span> <span class="nv">hashableIdentifier</span><span class="p">:</span> <span class="kt">AnyHashable</span> <span class="p">{</span> <span class="k">get</span> <span class="p">}</span>

    <span class="kd">func</span> <span class="nf">process</span><span class="p">(</span><span class="nv">image</span><span class="p">:</span> <span class="kt">Image</span><span class="p">,</span> <span class="nv">context</span><span class="p">:</span> <span class="kt">ImageProcessingContext</span><span class="p">?)</span> <span class="o">-&gt;</span> <span class="kt">Image</span><span class="p">?</span>
<span class="p">}</span>
</code></pre>

<p>The <code>process</code> method is self-explanatory. <code>identifier: String</code> is used by disk caches, and <code>hashableIdentifier: AnyHashable</code> is used by memory caches for which string manipulations would be too slow.</p>

<p>For one-off operations, use <code><a href="Enums/ImageProcessor/Anonymous.html">ImageProcessor.Anonymous</a></code> to create a processor with a closure.</p>
<h3 id='smart-decompression' class='heading'>Smart Decompression</h3>

<p>When you instantiate <code>UIImage</code> with <code>Data</code>, the data can be in a compressed format like <code>JPEG</code>. <code>UIImage</code> does <em>not</em> eagerly decompress this data until you display it. This leads to performance issues like scroll view stuttering. To avoid these it, Nuke automatically decompresses the data in the background. Decompression only runs if needed, it won&rsquo;t run for already processed images.</p>

<blockquote>
<p>See <a href="https://developer.apple.com/videos/play/wwdc2018/219">Image and Graphics Best Practices</a> to learn more about image decoding and downsampling.</p>
</blockquote>

<p><br/></p>
<h1 id='image-pipeline' class='heading'>Image Pipeline</h1>

<p>At the core of Nuke is <code><a href="Classes/ImagePipeline.html">ImagePipeline</a></code> class. Use the pipeline directly to load images without displaying them:</p>
<pre class="highlight swift"><code><span class="k">let</span> <span class="nv">task</span> <span class="o">=</span> <span class="kt">ImagePipeline</span><span class="o">.</span><span class="n">shared</span><span class="o">.</span><span class="nf">loadImage</span><span class="p">(</span>
    <span class="nv">with</span><span class="p">:</span> <span class="n">url</span><span class="p">,</span>
    <span class="nv">progress</span><span class="p">:</span> <span class="p">{</span> <span class="n">_</span><span class="p">,</span> <span class="n">completed</span><span class="p">,</span> <span class="n">total</span> <span class="k">in</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"progress updated"</span><span class="p">)</span>
    <span class="p">},</span>
    <span class="nv">completion</span><span class="p">:</span> <span class="p">{</span> <span class="nv">result</span><span class="p">:</span> <span class="kt">Result</span><span class="o">&lt;</span><span class="kt">ImageResponse</span><span class="p">,</span> <span class="kt">ImagePipeline</span><span class="o">.</span><span class="kt">Error</span><span class="o">&gt;</span> <span class="k">in</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"task completed"</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">)</span>
</code></pre>

<blockquote>
<p>In some cases, you only want to download the data without doing any expensive decoding or processing. You can do that with <code>loadData(with:progress:completion:)</code>.</p>
</blockquote>
<h3 id='code-imagetask-code' class='heading'><code><a href="Classes/ImageTask.html">ImageTask</a></code></h3>

<p>When you start the request, the pipeline returns an <code><a href="Classes/ImageTask.html">ImageTask</a></code> object, which can be used for cancelation and more.</p>
<pre class="highlight swift"><code><span class="n">task</span><span class="o">.</span><span class="nf">cancel</span><span class="p">()</span>
<span class="n">task</span><span class="o">.</span><span class="n">priority</span> <span class="o">=</span> <span class="o">.</span><span class="n">high</span>
</code></pre>
<h3 id='customize-image-pipeline' class='heading'>Customize Image Pipeline</h3>

<p>If you want to build a system that fits your specific needs, you won&rsquo;t be disappointed. There are a <em>lot of things</em> to tweak. You can set custom data loaders and caches, configure image encoders and decoders, change the number of concurrent operations for each individual stage, disable and enable features like deduplication and rate limiting, and more.</p>

<blockquote>
<p>To learn more see the inline documentation for <code><a href="Classes/ImagePipeline/Configuration.html">ImagePipeline.Configuration</a></code> and <a href="#h_design">Image Pipeline Overview</a>.</p>
</blockquote>

<p><img align="right" src="https://user-images.githubusercontent.com/1567433/59148462-94f60280-8a09-11e9-906a-6c7209b8f8c8.png" width="360"/></p>

<p>Here are some of the protocols which can be used for customization:</p>

<ul>
<li><code><a href="Protocols/DataLoading.html">DataLoading</a></code> – Download (or return cached) image data</li>
<li><code><a href="Protocols/DataCaching.html">DataCaching</a></code> – Store image data on disk</li>
<li><code><a href="Protocols/ImageDecoding.html">ImageDecoding</a></code> – Convert data into images</li>
<li><code><a href="Protocols/ImageEncoding.html">ImageEncoding</a></code> - Convert images into data</li>
<li><code><a href="Protocols/ImageProcessing.html">ImageProcessing</a></code> – Apply image transformations</li>
<li><code><a href="Protocols/ImageCaching.html">ImageCaching</a></code> – Store images into a memory cache</li>
</ul>

<p>The entire configuration is described by <code><a href="Classes/ImagePipeline/Configuration.html">ImagePipeline.Configuration</a></code> struct. To create a pipeline with a custom configuration either call <code>ImagePipeline(configuration:)</code> initializer or use the convenience one:</p>
<pre class="highlight swift"><code><span class="k">let</span> <span class="nv">pipeline</span> <span class="o">=</span> <span class="kt">ImagePipeline</span> <span class="p">{</span>
    <span class="nv">$0</span><span class="o">.</span><span class="n">dataLoader</span> <span class="o">=</span> <span class="o">...</span>
    <span class="nv">$0</span><span class="o">.</span><span class="n">dataLoadingQueue</span> <span class="o">=</span> <span class="o">...</span>
    <span class="nv">$0</span><span class="o">.</span><span class="n">imageCache</span> <span class="o">=</span> <span class="o">...</span>
    <span class="o">...</span>
<span class="p">}</span>
</code></pre>

<p>And then set the new pipeline as a default one:</p>
<pre class="highlight swift"><code><span class="kt">ImagePipeline</span><span class="o">.</span><span class="n">shared</span> <span class="o">=</span> <span class="n">pipeline</span>
</code></pre>
<h3 id='default-image-pipeline' class='heading'>Default Image Pipeline</h3>

<p>The default image pipeline is initialized with the following dependencies:</p>
<pre class="highlight swift"><code><span class="c1">// Shared image cache with a size limit of ~20% of available RAM.</span>
<span class="n">imageCache</span> <span class="o">=</span> <span class="kt">ImageCache</span><span class="o">.</span><span class="n">shared</span>

<span class="c1">// Data loader with a default `URLSessionConfiguration` and a custom `URLCache`</span>
<span class="c1">// with memory capacity 0, and disk capacity 150 MB.</span>
<span class="n">dataLoader</span> <span class="o">=</span> <span class="kt">DataLoader</span><span class="p">()</span>

<span class="c1">// Custom aggressive disk cache is disabled by default.</span>
<span class="n">dataCache</span> <span class="o">=</span> <span class="kc">nil</span>

<span class="c1">// By default uses the decoder from the global registry and the default encoder.</span>
<span class="n">makeImageDecoder</span> <span class="o">=</span> <span class="p">{</span> <span class="n">context</span> <span class="k">in</span> <span class="kt">ImageDecoderRegistry</span><span class="o">.</span><span class="n">shared</span><span class="o">.</span><span class="nf">decoder</span><span class="p">(</span><span class="nv">for</span><span class="p">:</span> <span class="n">context</span><span class="p">)</span> <span class="p">}</span>
<span class="n">makeImageEncoder</span> <span class="o">=</span> <span class="p">{</span> <span class="n">_</span> <span class="k">in</span> <span class="kt">ImageEncoder</span><span class="p">()</span> <span class="p">}</span>
</code></pre>

<p>Each operation in the pipeline runs on a dedicated queue:</p>
<pre class="highlight swift"><code><span class="n">dataLoadingQueue</span><span class="o">.</span><span class="n">maxConcurrentOperationCount</span> <span class="o">=</span> <span class="mi">6</span>
<span class="n">dataCachingQueue</span><span class="o">.</span><span class="n">maxConcurrentOperationCount</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">imageDecodingQueue</span><span class="o">.</span><span class="n">maxConcurrentOperationCount</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">imageEncodingQueue</span><span class="o">.</span><span class="n">maxConcurrentOperationCount</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">imageProcessingQueue</span><span class="o">.</span><span class="n">maxConcurrentOperationCount</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">imageDecompressingQueue</span><span class="o">.</span><span class="n">maxConcurrentOperationCount</span> <span class="o">=</span> <span class="mi">2</span>
</code></pre>

<p>There is a list of pipeline settings which you can tweak:</p>
<pre class="highlight swift"><code><span class="c1">// Automatically decompress images in the background by default.</span>
<span class="n">isDecompressionEnabled</span> <span class="o">=</span> <span class="kc">true</span>

<span class="c1">// Configure which images to store in the custom disk cache.</span>
<span class="n">isDataCachingForOriginalImageDataEnabled</span> <span class="o">=</span> <span class="kc">true</span>
<span class="n">isDataCachingForProcessedImagesEnabled</span> <span class="o">=</span> <span class="kc">false</span>

<span class="c1">// Avoid doing any duplicated work when loading or processing images.</span>
<span class="n">isDeduplicationEnabled</span> <span class="o">=</span> <span class="kc">true</span>

<span class="c1">// Rate limit the requests to prevent trashing of the subsystems.</span>
<span class="n">isRateLimiterEnabled</span> <span class="o">=</span> <span class="kc">true</span>

<span class="c1">// Progressive decoding is an opt-in feature because it is resource intensive.</span>
<span class="n">isProgressiveDecodingEnabled</span> <span class="o">=</span> <span class="kc">false</span>

<span class="c1">// If the data task is terminated (either because of a failure or a</span>
<span class="c1">// cancellation) and the image was partially loaded, the next load will</span>
<span class="c1">// resume where it was left off.</span>
<span class="n">isResumableDataEnabled</span> <span class="o">=</span> <span class="kc">true</span>
</code></pre>

<p>And also a few global options shared between all pipelines:</p>
<pre class="highlight swift"><code><span class="kt">ImagePipeline</span><span class="o">.</span><span class="kt">Configuration</span><span class="o">.</span><span class="n">isAnimatedImageDataEnabled</span> <span class="o">=</span> <span class="kc">false</span>

<span class="c1">// Enable to start using `os_signpost` to monitor the pipeline</span>
<span class="c1">// performance using Instruments.</span>
<span class="kt">ImagePipeline</span><span class="o">.</span><span class="kt">Configuration</span><span class="o">.</span><span class="n">isSignpostLoggingEnabled</span> <span class="o">=</span> <span class="kc">false</span>
</code></pre>

<p><br/></p>
<h1 id='caching' class='heading'>Caching</h1>
<h3 id='lru-memory-cache' class='heading'>LRU Memory Cache</h3>

<p>Default Nuke&rsquo;s <code><a href="Classes/ImagePipeline.html">ImagePipeline</a></code> has two cache layers.</p>

<p>First, there is a memory cache for storing processed images which are ready for display.</p>
<pre class="highlight swift"><code><span class="c1">// Configure cache</span>
<span class="kt">ImageCache</span><span class="o">.</span><span class="n">shared</span><span class="o">.</span><span class="n">costLimit</span> <span class="o">=</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">100</span> <span class="c1">// 100 MB</span>
<span class="kt">ImageCache</span><span class="o">.</span><span class="n">shared</span><span class="o">.</span><span class="n">countLimit</span> <span class="o">=</span> <span class="mi">100</span>
<span class="kt">ImageCache</span><span class="o">.</span><span class="n">shared</span><span class="o">.</span><span class="n">ttl</span> <span class="o">=</span> <span class="mi">120</span> <span class="c1">// Invalidate image after 120 sec</span>

<span class="c1">// Read and write images</span>
<span class="k">let</span> <span class="nv">request</span> <span class="o">=</span> <span class="kt">ImageRequest</span><span class="p">(</span><span class="nv">url</span><span class="p">:</span> <span class="n">url</span><span class="p">)</span>
<span class="kt">ImageCache</span><span class="o">.</span><span class="n">shared</span><span class="p">[</span><span class="n">request</span><span class="p">]</span> <span class="o">=</span> <span class="n">image</span>
<span class="k">let</span> <span class="nv">image</span> <span class="o">=</span> <span class="kt">ImageCache</span><span class="o">.</span><span class="n">shared</span><span class="p">[</span><span class="n">request</span><span class="p">]</span>

<span class="c1">// Clear cache</span>
<span class="kt">ImageCache</span><span class="o">.</span><span class="n">shared</span><span class="o">.</span><span class="nf">removeAll</span><span class="p">()</span>
</code></pre>

<p><code><a href="Classes/ImageCache.html">ImageCache</a></code> uses LRU algorithm – least recently used entries are removed first during the sweep.</p>
<h3 id='http-disk-cache' class='heading'>HTTP Disk Cache</h3>

<p>To store unprocessed image data Nuke uses a <code>URLCache</code> instance.</p>
<pre class="highlight swift"><code><span class="c1">// Configure cache</span>
<span class="kt">DataLoader</span><span class="o">.</span><span class="n">sharedUrlCache</span><span class="o">.</span><span class="n">diskCapacity</span> <span class="o">=</span> <span class="mi">100</span>
<span class="kt">DataLoader</span><span class="o">.</span><span class="n">sharedUrlCache</span><span class="o">.</span><span class="n">memoryCapacity</span> <span class="o">=</span> <span class="mi">0</span>

<span class="c1">// Read and write responses</span>
<span class="k">let</span> <span class="nv">request</span> <span class="o">=</span> <span class="kt">ImageRequest</span><span class="p">(</span><span class="nv">url</span><span class="p">:</span> <span class="n">url</span><span class="p">)</span>
<span class="k">let</span> <span class="nv">_</span> <span class="o">=</span> <span class="kt">DataLoader</span><span class="o">.</span><span class="n">sharedUrlCache</span><span class="o">.</span><span class="nf">cachedResponse</span><span class="p">(</span><span class="nv">for</span><span class="p">:</span> <span class="n">request</span><span class="o">.</span><span class="n">urlRequest</span><span class="p">)</span>
<span class="kt">DataLoader</span><span class="o">.</span><span class="n">sharedUrlCache</span><span class="o">.</span><span class="nf">removeCachedResponse</span><span class="p">(</span><span class="nv">for</span><span class="p">:</span> <span class="n">request</span><span class="o">.</span><span class="n">urlRequest</span><span class="p">)</span>

<span class="c1">// Clear cache</span>
<span class="kt">DataLoader</span><span class="o">.</span><span class="n">sharedUrlCache</span><span class="o">.</span><span class="nf">removeAllCachedResponses</span><span class="p">()</span>
</code></pre>
<h3 id='aggressive-lru-disk-cache' class='heading'>Aggressive LRU Disk Cache</h3>

<p>If HTTP caching is not your cup of tea, you can try using a custom LRU disk cache for fast and reliable <em>aggressive</em> data caching (ignores <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control">HTTP cache control</a>). You can enable it using the pipeline configuration.</p>
<pre class="highlight swift"><code><span class="kt">ImagePipeline</span> <span class="p">{</span>
    <span class="nv">$0</span><span class="o">.</span><span class="n">dataCache</span> <span class="o">=</span> <span class="k">try!</span> <span class="kt">DataCache</span><span class="p">(</span><span class="nv">name</span><span class="p">:</span> <span class="s">"com.myapp.datacache"</span><span class="p">)</span>

    <span class="c1">// Also consider disabling the native HTTP cache, see `DataLoader`.</span>
<span class="p">}</span>
</code></pre>

<p>By default, the pipeline stores only the original image data. To store the processed images enable <code>isDataCachingForProcessedImagesEnabled</code> and also consider disabling <code>isDataCachingForOriginalImageDataEnabled</code>. Every intermediate processed image will be stored in cache. So in the following scenario, there are going to be two entries in the disk cache (three if original image cache is also enabled):</p>
<pre class="highlight swift"><code><span class="k">let</span> <span class="nv">request</span> <span class="o">=</span> <span class="kt">ImageRequest</span><span class="p">(</span><span class="nv">url</span><span class="p">:</span> <span class="n">url</span><span class="p">,</span> <span class="nv">processors</span><span class="p">:</span> <span class="p">[</span>
    <span class="kt">ImageProcessor</span><span class="o">.</span><span class="kt">Resize</span><span class="p">(</span><span class="nv">size</span><span class="p">:</span> <span class="n">imageView</span><span class="o">.</span><span class="n">bounds</span><span class="o">.</span><span class="n">size</span><span class="p">),</span>
    <span class="kt">ImageProcessor</span><span class="o">.</span><span class="kt">CoreImageFilter</span><span class="p">(</span><span class="nv">name</span><span class="p">:</span> <span class="s">"CISepiaTone"</span><span class="p">)</span>
<span class="p">])</span>
</code></pre>

<p>To avoid storing unwanted images, compose the processors, <code><a href="Enums/ImageProcessor/Composition.html">ImageProcessor.Composition</a></code> is an easy way to do it.</p>

<p><br/></p>
<h1 id='advanced-features' class='heading'>Advanced Features</h1>
<h3 id='image-preheating' class='heading'>Image Preheating</h3>

<p>Prefetching images in advance can dramatically improve your app&rsquo;s user experience.</p>
<pre class="highlight swift"><code><span class="k">let</span> <span class="nv">preheater</span> <span class="o">=</span> <span class="kt">ImagePreheater</span><span class="p">()</span>
<span class="n">preheater</span><span class="o">.</span><span class="nf">startPreheating</span><span class="p">(</span><span class="nv">with</span><span class="p">:</span> <span class="n">urls</span><span class="p">)</span>

<span class="c1">// Cancels all of the preheating tasks created for the given requests.</span>
<span class="n">preheater</span><span class="o">.</span><span class="nf">stopPreheating</span><span class="p">(</span><span class="nv">with</span><span class="p">:</span> <span class="n">urls</span><span class="p">)</span>
</code></pre>

<p>Keep in mind that prefetching takes up users&rsquo; data and puts extra pressure on CPU and memory. To reduce the CPU and memory usage you have an option to choose only the disk cache as a prefetching destination:</p>
<pre class="highlight swift"><code><span class="c1">// The preheater with `.diskCache` destination will skip image data decoding</span>
<span class="c1">// entirely to reduce CPU and memory usage. It will still load the image data</span>
<span class="c1">// and store it in disk caches to be used later.</span>
<span class="k">let</span> <span class="nv">preheater</span> <span class="o">=</span> <span class="kt">ImagePreheater</span><span class="p">(</span><span class="nv">destination</span><span class="p">:</span> <span class="o">.</span><span class="n">diskCache</span><span class="p">)</span>
</code></pre>

<blockquote>
<p>On iOS, you can use <a href="https://developer.apple.com/reference/uikit/uitableviewdatasourceprefetching">prefetching APIs</a> in combination with <code><a href="Classes/ImagePreheater.html">ImagePreheater</a></code> to automate the process.</p>
</blockquote>
<h3 id='progressive-decoding' class='heading'>Progressive Decoding</h3>

<p>To enable progressive image decoding set <code>isProgressiveDecodingEnabled</code> configuration option to <code>true</code>.</p>

<p><img align="right" width="360" alt="Progressive JPEG" src="https://user-images.githubusercontent.com/1567433/59148764-3af73c00-8a0d-11e9-9d49-ded2d509380a.png"></p>
<pre class="highlight swift"><code><span class="k">let</span> <span class="nv">pipeline</span> <span class="o">=</span> <span class="kt">ImagePipeline</span> <span class="p">{</span>
    <span class="nv">$0</span><span class="o">.</span><span class="n">isProgressiveDecodingEnabled</span> <span class="o">=</span> <span class="kc">true</span>
<span class="p">}</span>
</code></pre>

<p>And that&rsquo;s it, the pipeline will automatically do the right thing and deliver the progressive scans via <code>progress</code> closure as they arrive:</p>
<pre class="highlight swift"><code><span class="k">let</span> <span class="nv">imageView</span> <span class="o">=</span> <span class="kt">UIImageView</span><span class="p">()</span>
<span class="k">let</span> <span class="nv">task</span> <span class="o">=</span> <span class="kt">ImagePipeline</span><span class="o">.</span><span class="n">shared</span><span class="o">.</span><span class="nf">loadImage</span><span class="p">(</span>
    <span class="nv">with</span><span class="p">:</span> <span class="n">url</span><span class="p">,</span>
    <span class="nv">progress</span><span class="p">:</span> <span class="p">{</span> <span class="n">response</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="k">in</span>
        <span class="k">if</span> <span class="k">let</span> <span class="nv">response</span> <span class="o">=</span> <span class="n">response</span> <span class="p">{</span>
            <span class="n">imageView</span><span class="o">.</span><span class="n">image</span> <span class="o">=</span> <span class="n">response</span><span class="p">?</span><span class="o">.</span><span class="n">image</span>
        <span class="p">}</span>
    <span class="p">},</span>
    <span class="nv">completion</span><span class="p">:</span> <span class="p">{</span> <span class="n">result</span> <span class="k">in</span>
        <span class="c1">// Display the final image</span>
    <span class="p">}</span>
<span class="p">)</span>
</code></pre>
<h3 id='animated-images' class='heading'>Animated Images</h3>

<p>Nuke extends <code>UIImage</code> with <code>animatedImageData</code> property. To enable it, set <code><a href="Classes/ImagePipeline/Configuration.html#/s:4Nuke13ImagePipelineC13ConfigurationV010isAnimatedB11DataEnabledSbvpZ">ImagePipeline.Configuration.isAnimatedImageDataEnabled</a></code> to <code>true</code>. If you do, then the pipeline will start attaching the original image data to the animated images.</p>

<p>There is no built-in way to render those images, but there are two extensions available: <a href="https://github.com/kean/Nuke-FLAnimatedImage-Plugin">FLAnimatedImage</a> and <a href="https://github.com/kean/Nuke-Gifu-Plugin">Gifu</a> which are both fast and efficient.</p>

<blockquote>
<p><code>GIF</code> is not the most efficient format for transferring and displaying animated images. The current best practice is to <a href="https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/replace-animated-gifs-with-video/">use short videos instead of GIFs</a> (e.g. <code>MP4</code>, <code>WebM</code>). There is a PoC available in the demo project which uses Nuke to load, cache and display an <code>MP4</code> video.</p>
</blockquote>
<h3 id='webp' class='heading'>WebP</h3>

<p>WebP support is provided by <a href="https://github.com/ryokosuge/Nuke-WebP-Plugin">Nuke WebP Plugin</a> built by <a href="https://github.com/ryokosuge">Ryo Kosuge</a>. Please follow the instructions from the repo.</p>
<h3 id='rxnuke' class='heading'>RxNuke</h3>

<p><a href="https://github.com/kean/RxNuke">RxNuke</a> adds <a href="https://github.com/ReactiveX/RxSwift">RxSwift</a> extensions for Nuke and enables some common use cases: <a href="https://github.com/kean/RxNuke#going-from-low-to-high-resolution">Going from low to high resolution</a> | <a href="https://github.com/kean/RxNuke#loading-the-first-available-image">Loading the first available image</a> | <a href="https://github.com/kean/RxNuke#showing-stale-image-while-validating-it">Showing stale image while validating it</a> | <a href="https://github.com/kean/RxNuke#load-multiple-images-display-all-at-once">Load multiple images, display all at once</a> | <a href="https://github.com/kean/RxNuke#auto-retry">Auto retry on failures</a> | <a href="https://github.com/kean/RxNuke#use-cases">And more</a></p>

<p>To get a taste of what you can do with this extension, take a look at how easy it is to load the low resolution image first and then switch to high resolution:</p>
<pre class="highlight swift"><code><span class="k">let</span> <span class="nv">pipeline</span> <span class="o">=</span> <span class="kt">ImagePipeline</span><span class="o">.</span><span class="n">shared</span>
<span class="kt">Observable</span><span class="o">.</span><span class="nf">concat</span><span class="p">(</span><span class="n">pipeline</span><span class="o">.</span><span class="nf">loadImage</span><span class="p">(</span><span class="nv">with</span><span class="p">:</span> <span class="n">lowResUrl</span><span class="p">)</span><span class="o">.</span><span class="n">orEmpty</span><span class="p">,</span>
                  <span class="n">pipeline</span><span class="o">.</span><span class="nf">loadImage</span><span class="p">(</span><span class="nv">with</span><span class="p">:</span> <span class="n">highResUtl</span><span class="p">)</span><span class="o">.</span><span class="n">orEmpty</span><span class="p">)</span>
    <span class="o">.</span><span class="nf">subscribe</span><span class="p">(</span><span class="nv">onNext</span><span class="p">:</span> <span class="p">{</span> <span class="n">imageView</span><span class="o">.</span><span class="n">image</span> <span class="o">=</span> <span class="nv">$0</span> <span class="p">})</span>
    <span class="o">.</span><span class="nf">disposed</span><span class="p">(</span><span class="nv">by</span><span class="p">:</span> <span class="n">disposeBag</span><span class="p">)</span>
</code></pre>

<p><br/></p>

<p><a name="h_design"></a></p>
<h1 id='image-pipeline-overview' class='heading'>Image Pipeline Overview</h1>

<p>This section describes in detail what happens when you perform a call like <code>Nuke.loadImage(with: url, into: view)</code>.</p>

<blockquote>
<p>As a visual aid, use this <a href="https://github.com/kean/Nuke/blob/master/Documentation/Assets/image-pipeline.svg">Block Diagram</a>.</p>
</blockquote>

<p>First, Nuke synchronously checks if the image is stored in the memory cache. If it&rsquo;s not, Nuke calls <code>pipeline.loadImage(with: request)</code> method.</p>

<p>The pipeline first checks if the image or image data exists in any of its caches. It checks if the processed image exists in the memory cache, then if the processed image data exists in the custom data cache (disabled by default), then if the data cache contains the original image data. Only if there is no cached data, the pipeline will start loading the data. When the data is loaded the pipeline decodes it, applies the processors, and decompresses the image in the background.</p>
<h3 id='data-loading-and-caching' class='heading'>Data Loading and Caching</h3>

<p>A <code><a href="Classes/DataLoader.html">DataLoader</a></code> class uses <a href="https://developer.apple.com/reference/foundation/nsurlsession"><code>URLSession</code></a> to load image data. The data is cached on disk using <a href="https://developer.apple.com/reference/foundation/urlcache"><code>URLCache</code></a>, which by default is initialized with memory capacity of 0 MB (we only store processed images in memory) and disk capacity of 150 MB.</p>

<blockquote>
<p>See <a href="https://kean.github.io/post/image-caching">Image Caching Guide</a> to learn more about HTTP cache.</p>
</blockquote>

<p>The <code>URLSession</code> class natively supports the following URL schemes: <code>data</code>, <code>file</code>, <code>ftp</code>, <code>http</code>, and <code>https</code>.</p>

<p>Most developers either implement their own networking layer or use a third-party framework. Nuke supports both of these workflows. You can integrate your custom networking layer by implementing <code><a href="Protocols/DataLoading.html">DataLoading</a></code> protocol.</p>

<blockquote>
<p>See <a href="https://github.com/kean/Nuke/blob/master/Documentation/Guides/Third%20Party%20Libraries.md#using-other-caching-libraries">Third Party Libraries</a> guide to learn more. See also <a href="https://github.com/kean/Nuke-Alamofire-Plugin">Alamofire Plugin</a>.</p>
</blockquote>
<h3 id='resumable-downloads' class='heading'>Resumable Downloads</h3>

<p>If the data task is terminated (either because of a failure or a cancelation) and the image was partially loaded, the next load will resume where it was left off. Resumable downloads require the server to support <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Range_requests">HTTP Range Requests</a>. Nuke supports both validators (<code>ETag</code> and <code>Last-Modified</code>). The resumable downloads are enabled by default.</p>
<h3 id='memory-cache' class='heading'>Memory Cache</h3>

<p>The processed images are stored in a fast in-memory cache (<code><a href="Classes/ImageCache.html">ImageCache</a></code>). It uses <a href="https://en.wikipedia.org/wiki/Cache_algorithms#Examples">LRU (least recently used)</a> replacement algorithm and has a limit of ~20% of available RAM. <code><a href="Classes/ImageCache.html">ImageCache</a></code> automatically evicts images on memory warnings and removes a portion of its contents when the application enters background.</p>
<h3 id='deduplication' class='heading'>Deduplication</h3>

<p>The pipeline avoids doing any duplicated work when loading images. For example, let&rsquo;s take these two requests:</p>
<pre class="highlight swift"><code><span class="k">let</span> <span class="nv">url</span> <span class="o">=</span> <span class="kt">URL</span><span class="p">(</span><span class="nv">string</span><span class="p">:</span> <span class="s">"http://example.com/image"</span><span class="p">)</span>
<span class="n">pipeline</span><span class="o">.</span><span class="nf">loadImage</span><span class="p">(</span><span class="nv">with</span><span class="p">:</span> <span class="kt">ImageRequest</span><span class="p">(</span><span class="nv">url</span><span class="p">:</span> <span class="n">url</span><span class="p">,</span> <span class="nv">processors</span><span class="p">:</span> <span class="p">[</span>
    <span class="kt">ImageProcessor</span><span class="o">.</span><span class="kt">Resize</span><span class="p">(</span><span class="nv">size</span><span class="p">:</span> <span class="kt">CGSize</span><span class="p">(</span><span class="nv">width</span><span class="p">:</span> <span class="mi">44</span><span class="p">,</span> <span class="nv">height</span><span class="p">:</span> <span class="mi">44</span><span class="p">)),</span>
    <span class="kt">ImageProcessor</span><span class="o">.</span><span class="kt">GaussianBlur</span><span class="p">(</span><span class="nv">radius</span><span class="p">:</span> <span class="mi">8</span><span class="p">)</span>
<span class="p">]))</span>
<span class="n">pipeline</span><span class="o">.</span><span class="nf">loadImage</span><span class="p">(</span><span class="nv">with</span><span class="p">:</span> <span class="kt">ImageRequest</span><span class="p">(</span><span class="nv">url</span><span class="p">:</span> <span class="n">url</span><span class="p">,</span> <span class="nv">processors</span><span class="p">:</span> <span class="p">[</span>
    <span class="kt">ImageProcessor</span><span class="o">.</span><span class="kt">Resize</span><span class="p">(</span><span class="nv">size</span><span class="p">:</span> <span class="kt">CGSize</span><span class="p">(</span><span class="nv">width</span><span class="p">:</span> <span class="mi">44</span><span class="p">,</span> <span class="nv">height</span><span class="p">:</span> <span class="mi">44</span><span class="p">))</span>
<span class="p">]))</span>
</code></pre>

<p>Nuke will load the data only once, resize the image once and blur it also only once. There is no duplicated work done. The work only gets cancelled when all the registered requests are, and the priority is based on the highest priority of the registered requests.</p>

<blockquote>
<p>Deduplication can be disabled using <code>isDeduplicationEnabled</code> configuration option.</p>
</blockquote>
<h3 id='performance' class='heading'>Performance</h3>

<p><img align="right" src="https://user-images.githubusercontent.com/1567433/59148850-1059b300-8a0e-11e9-95d5-0d4b4ffeaabc.png" width="360"/></p>

<p>Nuke is tuned to do as little work on the main thread as possible. It uses multiple optimization techniques to achieve that: reducing the number of allocations, reducing dynamic dispatch, backing some structs by reference typed storage to reduce ARC overhead, etc.</p>

<p>Nuke is fully asynchronous and performs well under stress. <code><a href="Classes/ImagePipeline.html">ImagePipeline</a></code> schedules its operations on dedicated queues. Each queue limits the number of concurrent tasks, respects the request priorities, and cancels the work as soon as possible. Under the extreme load, <code><a href="Classes/ImagePipeline.html">ImagePipeline</a></code> will also rate limit the requests to prevent trashing of the underlying systems.</p>

<p>If you want to see visually how the system behaves, how long each operation takes, and how many are performed in parallel, enable the <code>isSignpostLoggingEnabled</code> option and use <code>os_signpost</code> Instrument. For more information see <a href="https://developer.apple.com/documentation/os/logging">Apple Documentation: Logging</a> and <a href="https://developer.apple.com/videos/play/wwdc2018/405/">WWDC 2018: Measuring Performance Using Logging</a>.</p>

<p><a name="h_plugins"></a></p>
<h3 id='extensions' class='heading'>Extensions</h3>

<p>There is a variety of extensions available for Nuke:</p>

<table><thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead><tbody>
<tr>
<td><a href="https://github.com/kean/RxNuke"><strong>RxNuke</strong></a></td>
<td><a href="https://github.com/ReactiveX/RxSwift">RxSwift</a> extensions for Nuke with examples of common use cases solved by Rx</td>
</tr>
<tr>
<td><a href="https://github.com/kean/Nuke-Alamofire-Plugin"><strong>Alamofire</strong></a></td>
<td>Replace networking layer with <a href="https://github.com/Alamofire/Alamofire">Alamofire</a> and combine the power of both frameworks</td>
</tr>
<tr>
<td><a href="https://github.com/ryokosuge/Nuke-WebP-Plugin"><strong>WebP</strong></a></td>
<td><strong>[Community]</strong> <a href="https://developers.google.com/speed/webp/">WebP</a> support, built by <a href="https://github.com/ryokosuge">Ryo Kosuge</a></td>
</tr>
<tr>
<td><a href="https://github.com/kean/Nuke-Gifu-Plugin"><strong>Gifu</strong></a></td>
<td>Use <a href="https://github.com/kaishin/Gifu">Gifu</a> to load and display animated GIFs</td>
</tr>
<tr>
<td><a href="https://github.com/kean/Nuke-AnimatedImage-Plugin"><strong>FLAnimatedImage</strong></a></td>
<td>Use <a href="https://github.com/Flipboard/FLAnimatedImage">FLAnimatedImage</a> to load and display <a href="(https://www.youtube.com/watch?v=fEJqQMJrET4)">animated GIFs</a></td>
</tr>
</tbody></table>

<p><br/></p>

<p><a name="h_contribute"></a></p>
<h1 id='contribution' class='heading'>Contribution</h1>

<p><a href="https://trello.com/b/Us4rHryT/nuke">Nuke&rsquo;s roadmap</a> is managed in Trello and is publically available. If you&rsquo;d like to contribute, please feel free to create a PR.</p>

<p><a name="h_requirements"></a></p>
<h1 id='requirements' class='heading'>Requirements</h1>

<table><thead>
<tr>
<th>Nuke</th>
<th>Swift</th>
<th>Xcode</th>
<th>Platforms</th>
</tr>
</thead><tbody>
<tr>
<td>Nuke 8</td>
<td>Swift 5.0</td>
<td>Xcode 10.2</td>
<td>iOS 10.0 / watchOS 3.0 / macOS 10.12 / tvOS 10.0</td>
</tr>
<tr>
<td>Nuke 7.6 – 7.6.3</td>
<td>Swift 4.2 – 5.0</td>
<td>Xcode 10.1 – 10.2</td>
<td>iOS 10.0 / watchOS 3.0 / macOS 10.12 / tvOS 10.0</td>
</tr>
<tr>
<td>Nuke 7.2 – 7.5.2</td>
<td>Swift 4.0 – 4.2</td>
<td>Xcode 9.2 – 10.1</td>
<td>iOS 9.0 / watchOS 2.0 / macOS 10.10 / tvOS 9.0</td>
</tr>
</tbody></table>
<h1 id='license' class='heading'>License</h1>

<p>Nuke is available under the MIT license. See the LICENSE file for more info.</p>

          </section>
        </section>
        <section id="footer">
          <p>&copy; 2019 <a class="link" href="https://github.com/kean/Nuke" target="_blank" rel="external">Alexander Grebenyuk</a>. All rights reserved. (Last updated: 2019-06-12)</p>
          <p>Generated by <a class="link" href="https://github.com/realm/jazzy" target="_blank" rel="external">jazzy ♪♫ v0.9.6</a>, a <a class="link" href="https://realm.io" target="_blank" rel="external">Realm</a> project.</p>
        </section>
      </article>
    </div>
  </body>
</div>
</html>
