<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Nuke  Reference</title>
    <link rel="stylesheet" type="text/css" href="css/jazzy.css" />
    <link rel="stylesheet" type="text/css" href="css/highlight.css" />
    <meta charset='utf-8'>
    <script src="js/jquery.min.js" defer></script>
    <script src="js/jazzy.js" defer></script>
    
  </head>
  <body>
    <a title="Nuke  Reference"></a>
    <header>
      <div class="content-wrapper">
        <p><a href="index.html">Nuke Docs</a> (75% documented)</p>
        <p class="header-right"><a href="https://github.com/kean/nuke"><img src="img/gh.png"/>View on GitHub</a></p>
      </div>
    </header>
    <div class="content-wrapper">
      <p id="breadcrumbs">
        <a href="index.html">Nuke Reference</a>
        <img id="carat" src="img/carat.png" />
        Nuke  Reference
      </p>
    </div>
    <div class="content-wrapper">
      <nav class="sidebar">
        <ul class="nav-groups">
          <li class="nav-group-name">
            <a href="Classes.html">Classes</a>
            <ul class="nav-group-tasks">
              <li class="nav-group-task">
                <a href="Classes/DataCache.html">DataCache</a>
              </li>
              <li class="nav-group-task">
                <a href="Classes/DataLoader.html">DataLoader</a>
              </li>
              <li class="nav-group-task">
                <a href="Classes/DataLoader/Error.html">– Error</a>
              </li>
              <li class="nav-group-task">
                <a href="Classes/ImageCache.html">ImageCache</a>
              </li>
              <li class="nav-group-task">
                <a href="Classes/ImageDecoder.html">ImageDecoder</a>
              </li>
              <li class="nav-group-task">
                <a href="Classes/ImageDecoderRegistry.html">ImageDecoderRegistry</a>
              </li>
              <li class="nav-group-task">
                <a href="Classes/ImagePipeline.html">ImagePipeline</a>
              </li>
              <li class="nav-group-task">
                <a href="Classes/ImagePipeline/Configuration.html">– Configuration</a>
              </li>
              <li class="nav-group-task">
                <a href="Classes/ImagePipeline/Error.html">– Error</a>
              </li>
              <li class="nav-group-task">
                <a href="Classes/ImagePreheater.html">ImagePreheater</a>
              </li>
              <li class="nav-group-task">
                <a href="Classes/ImageResponse.html">ImageResponse</a>
              </li>
              <li class="nav-group-task">
                <a href="Classes/ImageTask.html">ImageTask</a>
              </li>
            </ul>
          </li>
          <li class="nav-group-name">
            <a href="Extensions.html">Extensions</a>
            <ul class="nav-group-tasks">
              <li class="nav-group-task">
                <a href="Extensions/Image.html">Image</a>
              </li>
              <li class="nav-group-task">
                <a href="Extensions/NSImageView.html">NSImageView</a>
              </li>
              <li class="nav-group-task">
                <a href="Extensions/UIImageView.html">UIImageView</a>
              </li>
            </ul>
          </li>
          <li class="nav-group-name">
            <a href="Functions.html">Functions</a>
            <ul class="nav-group-tasks">
              <li class="nav-group-task">
                <a href="Functions.html#/s:4Nuke13cancelRequestyAA15ImageDisplaying_So6UIViewCXc3for_tF">cancelRequest(for:)</a>
              </li>
              <li class="nav-group-task">
                <a href="Functions.html#/s:4Nuke9loadImageAA0C4TaskCSg10Foundation3URLV4with_AA0C14LoadingOptionsV7optionsAA0C10Displaying_So6UIViewCXc4intoyAA0C8ResponseCSg_s5Int64VAUtcSg8progressyAS_AA0C8PipelineC5ErrorOSgtcSg10completiontF">loadImage(with:options:into:progress:completion:)</a>
              </li>
              <li class="nav-group-task">
                <a href="Functions.html#/s:4Nuke9loadImageAA0C4TaskCSgAA0C7RequestV4with_AA0C14LoadingOptionsV7optionsAA0C10Displaying_So6UIViewCXc4intoyAA0C8ResponseCSg_s5Int64VATtcSg8progressyAR_AA0C8PipelineC5ErrorOSgtcSg10completiontF">loadImage(with:options:into:progress:completion:)</a>
              </li>
            </ul>
          </li>
          <li class="nav-group-name">
            <a href="Protocols.html">Protocols</a>
            <ul class="nav-group-tasks">
              <li class="nav-group-task">
                <a href="Protocols/Cancellable.html">Cancellable</a>
              </li>
              <li class="nav-group-task">
                <a href="Protocols/DataCaching.html">DataCaching</a>
              </li>
              <li class="nav-group-task">
                <a href="Protocols/DataLoading.html">DataLoading</a>
              </li>
              <li class="nav-group-task">
                <a href="Protocols/ImageCaching.html">ImageCaching</a>
              </li>
              <li class="nav-group-task">
                <a href="Protocols/ImageDecoding.html">ImageDecoding</a>
              </li>
              <li class="nav-group-task">
                <a href="Protocols/ImageDisplaying.html">ImageDisplaying</a>
              </li>
              <li class="nav-group-task">
                <a href="Protocols/ImageProcessing.html">ImageProcessing</a>
              </li>
            </ul>
          </li>
          <li class="nav-group-name">
            <a href="Structs.html">Structures</a>
            <ul class="nav-group-tasks">
              <li class="nav-group-task">
                <a href="Structs/AnyImageProcessor.html">AnyImageProcessor</a>
              </li>
              <li class="nav-group-task">
                <a href="Structs/ImageDecodingContext.html">ImageDecodingContext</a>
              </li>
              <li class="nav-group-task">
                <a href="Structs/ImageDecompressor.html">ImageDecompressor</a>
              </li>
              <li class="nav-group-task">
                <a href="Structs/ImageDecompressor/ContentMode.html">– ContentMode</a>
              </li>
              <li class="nav-group-task">
                <a href="Structs/ImageLoadingOptions.html">ImageLoadingOptions</a>
              </li>
              <li class="nav-group-task">
                <a href="Structs/ImageLoadingOptions/ContentModes.html">– ContentModes</a>
              </li>
              <li class="nav-group-task">
                <a href="Structs/ImageLoadingOptions/Transition.html">– Transition</a>
              </li>
              <li class="nav-group-task">
                <a href="Structs/ImageProcessingContext.html">ImageProcessingContext</a>
              </li>
              <li class="nav-group-task">
                <a href="Structs/ImageRequest.html">ImageRequest</a>
              </li>
              <li class="nav-group-task">
                <a href="Structs/ImageRequest/MemoryCacheOptions.html">– MemoryCacheOptions</a>
              </li>
              <li class="nav-group-task">
                <a href="Structs/ImageRequest/Priority.html">– Priority</a>
              </li>
              <li class="nav-group-task">
                <a href="Structs/ImageTaskMetrics.html">ImageTaskMetrics</a>
              </li>
              <li class="nav-group-task">
                <a href="Structs/ImageTaskMetrics/SessionMetrics.html">– SessionMetrics</a>
              </li>
            </ul>
          </li>
          <li class="nav-group-name">
            <a href="Typealiases.html">Type Aliases</a>
            <ul class="nav-group-tasks">
              <li class="nav-group-task">
                <a href="Typealiases.html#/Image">Image</a>
              </li>
              <li class="nav-group-task">
                <a href="Typealiases.html#/s:4Nuke5Imagea">Image</a>
              </li>
              <li class="nav-group-task">
                <a href="Typealiases.html#/ImageDisplayingView">ImageDisplayingView</a>
              </li>
              <li class="nav-group-task">
                <a href="Typealiases.html#/s:4Nuke19ImageDisplayingViewa">ImageDisplayingView</a>
              </li>
            </ul>
          </li>
        </ul>
      </nav>
      <article class="main-content">
        <section>
          <section class="section">
            
            <p align="center"><img src="https://cloud.githubusercontent.com/assets/1567433/13918338/f8670eea-ef7f-11e5-814d-f15bdfd6b2c0.png" height="180"/>

<p align="center">
<img src="https://img.shields.io/cocoapods/v/Nuke.svg?label=version">
<img src="https://img.shields.io/badge/supports-CocoaPods%20%7C%20Carthage%20%7C%20SwiftPM-green.svg">
<img src="https://img.shields.io/badge/platforms-iOS%20%7C%20macOS%20%7C%20watchOS%20%7C%20tvOS-lightgrey.svg">
<a href="https://travis-ci.org/kean/Nuke"><img src="https://img.shields.io/travis/kean/Nuke/master.svg"></a>
</p>

<p>A powerful <strong>image loading</strong> and <strong>caching</strong> system. It makes simple tasks like loading images into views extremely simple, while also supporting advanced features for more demanding apps.</p>

<ul>
<li>Fast LRU memory cache, native HTTP disk cache, and custom aggressive LRU disk cache</li>
<li>Progressive image loading (progressive JPEG and WebP)</li>
<li>Resumable downloads, request prioritization, deduplication, rate limiting and more</li>
<li><a href="https://github.com/kean/Nuke-Alamofire-Plugin">Alamofire</a>, <a href="https://github.com/ryokosuge/Nuke-WebP-Plugin">WebP</a>, <a href="https://github.com/kean/Nuke-Gifu-Plugin">Gifu</a>, <a href="https://github.com/kean/Nuke-FLAnimatedImage-Plugin">FLAnimatedImage</a> extensions</li>
<li><a href="https://github.com/kean/RxNuke">RxNuke</a> - <a href="https://github.com/ReactiveX/RxSwift">RxSwift</a> extensions</li>
<li>Automates <a href="https://kean.github.io/post/image-preheating">prefetching</a> with <a href="https://github.com/kean/Preheat">Preheat</a> (<em>deprecated in iOS 10</em>)</li>
</ul>
<h1 id='a-name-h_getting_started-a-quick-start' class='heading'><a name="h_getting_started"></a>Quick Start</h1>

<blockquote>
<p>Upgrading from the previous version? Use a <a href="https://github.com/kean/Nuke/blob/master/Documentation/Migrations"><strong>Migration Guide</strong></a>.</p>
</blockquote>

<ul>
<li>Basic <a href="#h_usage"><strong>Usage Guide</strong></a>, the best place to start

<ul>
<li><a href="#load-image-into-image-view">Load Image into Image View</a></li>
<li><a href="#placeholders-transitions-and-more">Placeholders, Transitions and More</a></li>
<li><a href="#image-requests">Image Requests</a>, <a href="#process-an-image">Process an Image</a></li>
<li><a href="#image-pipeline">Image Pipeline</a>, <a href="#configuring-image-pipeline">Configuring Image Pipeline</a></li>
</ul></li>
<li><a href="#advanced-usage"><strong>Advanced Usage Guide</strong></a>

<ul>
<li><a href="#memory-cache">Memory Cache</a>, <a href="#http-disk-cache">HTTP Disk Cache</a>, <a href="#aggressive-disk-cache">Aggressive Disk Cache</a></li>
<li><a href="#preheat-images">Preheat Images</a></li>
<li><a href="#progressive-decoding">Progressive Decoding</a>, <a href="#animated-images">Animated Images</a>, <a href="#webp">WebP</a></li>
<li><a href="#rxnuke">RxNuke</a></li>
</ul></li>
<li>Detailed <a href="#h_design"><strong>Image Pipeline</strong></a> description</li>
<li>An entire section dedicated to <a href="#h_performance"><strong>Performance</strong></a></li>
<li>List of <a href="#h_plugins"><strong>Extensions</strong></a></li>
<li><a href="#h_contribute"><strong>Contributing</strong></a> and roadmap</li>
<li><a href="#h_requirements"><strong>Requirements</strong></a></li>
</ul>

<p>More information is available in <a href="https://github.com/kean/Nuke/blob/master/Documentation/"><strong>Documentation</strong></a> directory and a full <a href="https://kean.github.io/Nuke/reference/7.2/index.html"><strong>API Reference</strong></a>. When you are ready to install Nuke you can follow an <a href="https://github.com/kean/Nuke/blob/master/Documentation/Guides/Installation%20Guide.md"><strong>Installation Guide</strong></a> - all major package managers are supported.</p>
<h1 id='a-name-h_usage-a-usage' class='heading'><a name="h_usage"></a>Usage</h1>
<h4 id='load-image-into-image-view' class='heading'>Load Image into Image View</h4>

<p>You can load an image into an image view with a single line of code.</p>
<pre class="highlight swift"><code><span class="kt">Nuke</span><span class="o">.</span><span class="nf">loadImage</span><span class="p">(</span><span class="nv">with</span><span class="p">:</span> <span class="n">url</span><span class="p">,</span> <span class="nv">into</span><span class="p">:</span> <span class="n">imageView</span><span class="p">)</span>
</code></pre>

<p>Nuke will automatically load image data, decompress it in the background, store image in memory cache and display it.</p>

<blockquote>
<p>To learn more about the <code><a href="Classes/ImagePipeline.html">ImagePipeline</a></code> <a href="#h_design">see the dedicated section</a>.</p>
</blockquote>

<p>When you request a new image for the view, the previous outstanding request gets canceled and the image is set to <code>nil</code>. The request also gets canceled automatically when the view is deallocated.</p>
<pre class="highlight swift"><code><span class="kd">func</span> <span class="nf">collectionView</span><span class="p">(</span><span class="n">_</span> <span class="nv">collectionView</span><span class="p">:</span> <span class="kt">UICollectionView</span><span class="p">,</span> <span class="n">cellForItemAt</span> <span class="nv">indexPath</span><span class="p">:</span> <span class="kt">IndexPath</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">UICollectionViewCell</span> <span class="p">{</span>
    <span class="o">...</span>
    <span class="kt">Nuke</span><span class="o">.</span><span class="nf">loadImage</span><span class="p">(</span><span class="nv">with</span><span class="p">:</span> <span class="n">url</span><span class="p">,</span> <span class="nv">into</span><span class="p">:</span> <span class="n">cell</span><span class="o">.</span><span class="n">imageView</span><span class="p">)</span>
    <span class="o">...</span>
<span class="p">}</span>
</code></pre>
<h4 id='placeholders-transitions-and-more' class='heading'>Placeholders, Transitions and More</h4>

<p>Use an  <code>options</code> parameter (<code><a href="Structs/ImageLoadingOptions.html">ImageLoadingOptions</a></code>)  to customize the way images are loaded and displayed. You can provide a placeholder, select one of the built-in transitions or provide a custom one.</p>
<pre class="highlight swift"><code><span class="kt">Nuke</span><span class="o">.</span><span class="nf">loadImage</span><span class="p">(</span>
    <span class="nv">with</span><span class="p">:</span> <span class="n">url</span><span class="p">,</span>
    <span class="nv">options</span><span class="p">:</span> <span class="kt">ImageLoadingOptions</span><span class="p">(</span>
        <span class="nv">placeholder</span><span class="p">:</span> <span class="kt">UIImage</span><span class="p">(</span><span class="nv">named</span><span class="p">:</span> <span class="s">"placeholder"</span><span class="p">),</span>
        <span class="nv">transition</span><span class="p">:</span> <span class="o">.</span><span class="nf">fadeIn</span><span class="p">(</span><span class="nv">duration</span><span class="p">:</span> <span class="mf">0.33</span><span class="p">)</span>
    <span class="p">),</span>
    <span class="nv">into</span><span class="p">:</span> <span class="n">imageView</span>
<span class="p">)</span>
</code></pre>

<p>There is a very common scenario when the placeholder (or the failure image) needs to be displayed with a <em>content mode</em> different from the one used for the loaded image.</p>
<pre class="highlight swift"><code><span class="k">let</span> <span class="nv">options</span> <span class="o">=</span> <span class="kt">ImageLoadingOptions</span><span class="p">(</span>
    <span class="nv">placeholder</span><span class="p">:</span> <span class="kt">UIImage</span><span class="p">(</span><span class="nv">named</span><span class="p">:</span> <span class="s">"placeholder"</span><span class="p">),</span>
    <span class="nv">failureImage</span><span class="p">:</span> <span class="kt">UIImage</span><span class="p">(</span><span class="nv">named</span><span class="p">:</span> <span class="s">"failure_image"</span><span class="p">),</span>
    <span class="n">contentModes</span> <span class="o">=</span> <span class="o">.</span><span class="nf">init</span><span class="p">(</span>
        <span class="nv">success</span><span class="p">:</span> <span class="o">.</span><span class="n">scaleAspectFill</span><span class="p">,</span>
        <span class="nv">failure</span><span class="p">:</span> <span class="o">.</span><span class="n">center</span><span class="p">,</span>
        <span class="nv">placeholder</span><span class="p">:</span> <span class="o">.</span><span class="n">center</span>
    <span class="p">)</span>
<span class="p">)</span>

<span class="kt">Nuke</span><span class="o">.</span><span class="nf">loadImage</span><span class="p">(</span><span class="nv">with</span><span class="p">:</span> <span class="n">url</span><span class="p">,</span> <span class="nv">options</span><span class="p">:</span> <span class="n">options</span><span class="p">,</span> <span class="nv">into</span><span class="p">:</span> <span class="n">imageView</span><span class="p">)</span>
</code></pre>

<p>To make all image views in the app share the same behavior modify <code><a href="Structs/ImageLoadingOptions.html#/s:4Nuke19ImageLoadingOptionsV6sharedACvpZ">ImageLoadingOptions.shared</a></code>.</p>

<blockquote>
<p>If <code><a href="Structs/ImageLoadingOptions.html">ImageLoadingOptions</a></code> are missing a feature that you need, please use <code><a href="Classes/ImagePipeline.html">ImagePipeline</a></code> directly. If you think that everyone could benefit from this feature, PRs are welcome.</p>
</blockquote>
<h4 id='image-requests' class='heading'>Image Requests</h4>

<p>Each request is represented by an <code><a href="Structs/ImageRequest.html">ImageRequest</a></code> struct. A request can be created either with <code>URL</code> or <code>URLRequest</code>.</p>
<pre class="highlight swift"><code><span class="k">var</span> <span class="nv">request</span> <span class="o">=</span> <span class="kt">ImageRequest</span><span class="p">(</span><span class="nv">url</span><span class="p">:</span> <span class="n">url</span><span class="p">)</span>
<span class="c1">// var request = ImageRequest(urlRequest: URLRequest(url: url))</span>

<span class="c1">// Change memory cache policy:</span>
<span class="n">request</span><span class="o">.</span><span class="n">memoryCacheOptions</span><span class="o">.</span><span class="n">isWriteAllowed</span> <span class="o">=</span> <span class="kc">false</span>

<span class="c1">// Update the request priority:</span>
<span class="n">request</span><span class="o">.</span><span class="n">priority</span> <span class="o">=</span> <span class="o">.</span><span class="n">high</span>

<span class="kt">Nuke</span><span class="o">.</span><span class="nf">loadImage</span><span class="p">(</span><span class="nv">with</span><span class="p">:</span> <span class="n">request</span><span class="p">,</span> <span class="nv">into</span><span class="p">:</span> <span class="n">imageView</span><span class="p">)</span>
</code></pre>
<h4 id='process-an-image' class='heading'>Process an Image</h4>

<p>Resize an image using special <code><a href="Structs/ImageRequest.html">ImageRequest</a></code> initializer.</p>
<pre class="highlight swift"><code><span class="c1">// Target size is in pixels.</span>
<span class="kt">ImageRequest</span><span class="p">(</span><span class="nv">url</span><span class="p">:</span> <span class="n">url</span><span class="p">,</span> <span class="nv">targetSize</span><span class="p">:</span> <span class="kt">CGSize</span><span class="p">(</span><span class="nv">width</span><span class="p">:</span> <span class="mi">640</span><span class="p">,</span> <span class="nv">height</span><span class="p">:</span> <span class="mi">320</span><span class="p">),</span> <span class="nv">contentMode</span><span class="p">:</span> <span class="o">.</span><span class="n">aspectFill</span><span class="p">)</span>
</code></pre>

<p>Perform custom tranformation using <code>processed(key:closure:)</code> method. Her&rsquo;s how to create a circular avatar using <a href="https://github.com/gavinbunney/Toucan">Toucan</a>.</p>
<pre class="highlight swift"><code><span class="kt">ImageRequest</span><span class="p">(</span><span class="nv">url</span><span class="p">:</span> <span class="n">url</span><span class="p">)</span><span class="o">.</span><span class="nf">process</span><span class="p">(</span><span class="nv">key</span><span class="p">:</span> <span class="s">"circularAvatar"</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">Toucan</span><span class="p">(</span><span class="nv">image</span><span class="p">:</span> <span class="nv">$0</span><span class="p">)</span><span class="o">.</span><span class="nf">maskWithEllipse</span><span class="p">()</span><span class="o">.</span><span class="n">image</span>
<span class="p">}</span>
</code></pre>

<p>All those APIs are built on top of <code><a href="Protocols/ImageProcessing.html">ImageProcessing</a></code> protocol which you can also use to implement custom processors. Keep in mind that <code><a href="Protocols/ImageProcessing.html">ImageProcessing</a></code> also requires <code>Equatable</code> conformance which helps Nuke identify images in memory cache.</p>

<blockquote>
<p>See <a href="https://github.com/kean/Nuke/blob/master/Documentation/Guides/Core%20Image%20Integration%20Guide.md">Core Image Integration Guide</a> for info about using Core Image with Nuke</p>
</blockquote>
<h4 id='image-pipeline' class='heading'>Image Pipeline</h4>

<p>Use <code><a href="Classes/ImagePipeline.html">ImagePipeline</a></code> directly to load images without a view.</p>
<pre class="highlight swift"><code><span class="k">let</span> <span class="nv">task</span> <span class="o">=</span> <span class="kt">ImagePipeline</span><span class="o">.</span><span class="n">shared</span><span class="o">.</span><span class="nf">loadImage</span><span class="p">(</span>
    <span class="nv">with</span><span class="p">:</span> <span class="n">url</span><span class="p">,</span>
    <span class="nv">progress</span><span class="p">:</span> <span class="p">{</span> <span class="n">_</span><span class="p">,</span> <span class="n">completed</span><span class="p">,</span> <span class="n">total</span> <span class="k">in</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"progress updated"</span><span class="p">)</span>
    <span class="p">},</span>
    <span class="nv">completion</span><span class="p">:</span> <span class="p">{</span> <span class="n">response</span><span class="p">,</span> <span class="n">error</span> <span class="k">in</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"task completed"</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">)</span>
</code></pre>

<p>Tasks can be used to monitor download progress, cancel the requests, and dynamically update download priority.</p>
<pre class="highlight swift"><code><span class="n">task</span><span class="o">.</span><span class="nf">cancel</span><span class="p">()</span>
<span class="n">task</span><span class="o">.</span><span class="nf">setPriority</span><span class="p">(</span><span class="o">.</span><span class="n">high</span><span class="p">)</span>
</code></pre>

<blockquote>
<p>To learn more about the <code><a href="Classes/ImagePipeline.html">ImagePipeline</a></code> <a href="#h_design">see the dedicated section</a>.</p>
</blockquote>
<h4 id='configuring-image-pipeline' class='heading'>Configuring Image Pipeline</h4>

<p>Apart from using a shared <code><a href="Classes/ImagePipeline.html">ImagePipeline</a></code> instance, you can create your own.</p>
<pre class="highlight swift"><code><span class="k">let</span> <span class="nv">pipeline</span> <span class="o">=</span> <span class="kt">ImagePipeline</span> <span class="p">{</span>
    <span class="nv">$0</span><span class="o">.</span><span class="n">dataLoader</span> <span class="o">=</span> <span class="o">...</span>
    <span class="nv">$0</span><span class="o">.</span><span class="n">dataLoadingQueue</span> <span class="o">=</span> <span class="o">...</span>
    <span class="nv">$0</span><span class="o">.</span><span class="n">imageCache</span> <span class="o">=</span> <span class="o">...</span>
    <span class="o">...</span>
<span class="p">}</span>

<span class="c1">// When you're done you can make the pipeline a shared one:</span>
<span class="kt">ImagePipeline</span><span class="o">.</span><span class="n">shared</span> <span class="o">=</span> <span class="n">pipeline</span>
</code></pre>
<h1 id='advanced-usage' class='heading'>Advanced Usage</h1>
<h4 id='memory-cache' class='heading'>Memory Cache</h4>

<p>Default Nuke&rsquo;s <code><a href="Classes/ImagePipeline.html">ImagePipeline</a></code> has two cache layers.</p>

<p>First, there is a memory cache for storing processed images ready for display. You can get a direct access to this cache:</p>
<pre class="highlight swift"><code><span class="c1">// Configure cache</span>
<span class="kt">ImageCache</span><span class="o">.</span><span class="n">shared</span><span class="o">.</span><span class="n">costLimit</span> <span class="o">=</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">100</span> <span class="c1">// 100 MB</span>
<span class="kt">ImageCache</span><span class="o">.</span><span class="n">shared</span><span class="o">.</span><span class="n">countLimit</span> <span class="o">=</span> <span class="mi">100</span>
<span class="kt">ImageCache</span><span class="o">.</span><span class="n">shared</span><span class="o">.</span><span class="n">ttl</span> <span class="o">=</span> <span class="mi">120</span> <span class="c1">// Invalidate image after 120 sec</span>

<span class="c1">// Read and write images</span>
<span class="k">let</span> <span class="nv">request</span> <span class="o">=</span> <span class="kt">ImageRequest</span><span class="p">(</span><span class="nv">url</span><span class="p">:</span> <span class="n">url</span><span class="p">)</span>
<span class="kt">ImageCache</span><span class="o">.</span><span class="n">shared</span><span class="p">[</span><span class="n">request</span><span class="p">]</span> <span class="o">=</span> <span class="n">image</span>
<span class="k">let</span> <span class="nv">image</span> <span class="o">=</span> <span class="kt">ImageCache</span><span class="o">.</span><span class="n">shared</span><span class="p">[</span><span class="n">request</span><span class="p">]</span>

<span class="c1">// Clear cache</span>
<span class="kt">ImageCache</span><span class="o">.</span><span class="n">shared</span><span class="o">.</span><span class="nf">removeAll</span><span class="p">()</span>
</code></pre>
<h4 id='http-disk-cache' class='heading'>HTTP Disk Cache</h4>

<p>To store unprocessed image data Nuke uses a <code>URLCache</code> instance:</p>
<pre class="highlight swift"><code><span class="c1">// Configure cache</span>
<span class="kt">DataLoader</span><span class="o">.</span><span class="n">sharedUrlCache</span><span class="o">.</span><span class="n">diskCapacity</span> <span class="o">=</span> <span class="mi">100</span>
<span class="kt">DataLoader</span><span class="o">.</span><span class="n">sharedUrlCache</span><span class="o">.</span><span class="n">memoryCapacity</span> <span class="o">=</span> <span class="mi">0</span>

<span class="c1">// Read and write responses</span>
<span class="k">let</span> <span class="nv">request</span> <span class="o">=</span> <span class="kt">ImageRequest</span><span class="p">(</span><span class="nv">url</span><span class="p">:</span> <span class="n">url</span><span class="p">)</span>
<span class="k">let</span> <span class="nv">_</span> <span class="o">=</span> <span class="kt">DataLoader</span><span class="o">.</span><span class="n">sharedUrlCache</span><span class="o">.</span><span class="nf">cachedResponse</span><span class="p">(</span><span class="nv">for</span><span class="p">:</span> <span class="n">request</span><span class="o">.</span><span class="n">urlRequest</span><span class="p">)</span>
<span class="kt">DataLoader</span><span class="o">.</span><span class="n">sharedUrlCache</span><span class="o">.</span><span class="nf">removeCachedResponse</span><span class="p">(</span><span class="nv">for</span><span class="p">:</span> <span class="n">request</span><span class="o">.</span><span class="n">urlRequest</span><span class="p">)</span>

<span class="c1">// Clear cache</span>
<span class="kt">DataLoader</span><span class="o">.</span><span class="n">sharedUrlCache</span><span class="o">.</span><span class="nf">removeAllCachedResponses</span><span class="p">()</span>
</code></pre>
<h4 id='aggressive-disk-cache' class='heading'>Aggressive Disk Cache</h4>

<p>A custom LRU disk cache can be used for fast and reliable <em>aggressive</em> data caching (ignores <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control">HTTP cache control</a>). You can enable it using pipeline&rsquo;s configuration.</p>
<pre class="highlight swift"><code><span class="nv">$0</span><span class="o">.</span><span class="n">dataCache</span> <span class="o">=</span> <span class="k">try!</span> <span class="kt">DataCache</span><span class="p">(</span><span class="nv">name</span><span class="p">:</span> <span class="s">"com.myapp.datacache"</span><span class="p">)</span>
<span class="c1">// On Swift 4.1 and lower you'll also need to provide a `FilenameGenerator`.</span>
</code></pre>

<p>If you enable aggressive disk cache, make sure that you also disable native URL cache (see <code><a href="Classes/DataLoader.html">DataLoader</a></code>), or you might end up storing the same image data twice.</p>

<blockquote>
<p><code><a href="Classes/DataCache.html">DataCache</a></code> type implements public <code><a href="Protocols/DataCaching.html">DataCaching</a></code> protocol which can be used for implementing custom data caches.</p>
</blockquote>
<h4 id='preheat-images' class='heading'>Preheat Images</h4>

<p><a href="https://kean.github.io/post/image-preheating">Preheating</a> (prefetching) means loading images ahead of time in anticipation of their use. Nuke provides a <code><a href="Classes/ImagePreheater.html">ImagePreheater</a></code> class that does just that.</p>
<pre class="highlight swift"><code><span class="k">let</span> <span class="nv">preheater</span> <span class="o">=</span> <span class="kt">ImagePreheater</span><span class="p">(</span><span class="nv">pipeline</span><span class="p">:</span> <span class="kt">ImagePipeline</span><span class="o">.</span><span class="n">shared</span><span class="p">)</span>

<span class="k">let</span> <span class="nv">requests</span> <span class="o">=</span> <span class="n">urls</span><span class="o">.</span><span class="n">map</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">request</span> <span class="o">=</span> <span class="kt">ImageRequest</span><span class="p">(</span><span class="nv">url</span><span class="p">:</span> <span class="nv">$0</span><span class="p">)</span>
    <span class="n">request</span><span class="o">.</span><span class="n">priority</span> <span class="o">=</span> <span class="o">.</span><span class="n">low</span>
    <span class="k">return</span> <span class="n">request</span>
<span class="p">}</span>

<span class="c1">// User enters the screen:</span>
<span class="n">preheater</span><span class="o">.</span><span class="nf">startPreheating</span><span class="p">(</span><span class="nv">for</span><span class="p">:</span> <span class="n">requests</span><span class="p">)</span>

<span class="c1">// User leaves the screen:</span>
<span class="n">preheater</span><span class="o">.</span><span class="nf">stopPreheating</span><span class="p">(</span><span class="nv">for</span><span class="p">:</span> <span class="n">requests</span><span class="p">)</span>
</code></pre>

<p>You can use Nuke in combination with <a href="https://github.com/kean/Preheat">Preheat</a> library which automates preheating of content in <code>UICollectionView</code> and <code>UITableView</code>. On iOS 10.0 you might want to use new <a href="https://developer.apple.com/reference/uikit/uitableviewdatasourceprefetching">prefetching APIs</a> provided by iOS instead.</p>

<blockquote>
<p>Check out <a href="https://github.com/kean/Nuke/blob/master/Documentation/Guides/Performance%20Guide.md">Performance Guide</a> to see what else you can do to improve performance</p>
</blockquote>
<h4 id='progressive-decoding' class='heading'>Progressive Decoding</h4>

<p>To use progressive image loading you need a pipeline with progressive decoding enabled.</p>
<pre class="highlight swift"><code><span class="k">let</span> <span class="nv">pipeline</span> <span class="o">=</span> <span class="kt">ImagePipeline</span> <span class="p">{</span>
    <span class="nv">$0</span><span class="o">.</span><span class="n">isProgressiveDecodingEnabled</span> <span class="o">=</span> <span class="kc">true</span>
<span class="p">}</span>
</code></pre>

<p>And that&rsquo;s it, you can start observing images as they are produced by the pipeline. The progress handler also works as a progressive image handler.</p>
<pre class="highlight swift"><code><span class="k">let</span> <span class="nv">imageView</span> <span class="o">=</span> <span class="kt">UIImageView</span><span class="p">()</span>
<span class="k">let</span> <span class="nv">task</span> <span class="o">=</span> <span class="kt">ImagePipeline</span><span class="o">.</span><span class="n">shared</span><span class="o">.</span><span class="nf">loadImage</span><span class="p">(</span>
    <span class="nv">with</span><span class="p">:</span> <span class="n">url</span><span class="p">,</span>
    <span class="nv">progress</span><span class="p">:</span> <span class="p">{</span> <span class="n">response</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="k">in</span>
        <span class="n">imageView</span><span class="o">.</span><span class="n">image</span> <span class="o">=</span> <span class="n">response</span><span class="p">?</span><span class="o">.</span><span class="n">image</span>
    <span class="p">},</span>
    <span class="nv">completion</span><span class="p">:</span> <span class="p">{</span> <span class="n">response</span><span class="p">,</span> <span class="n">_</span> <span class="k">in</span>
        <span class="n">imageView</span><span class="o">.</span><span class="n">image</span> <span class="o">=</span> <span class="n">response</span><span class="p">?</span><span class="o">.</span><span class="n">image</span>
    <span class="p">}</span>
<span class="p">)</span>
</code></pre>

<blockquote>
<p>See <q>Progressive Decoding</q> demo to see progressive JPEG in practice.</p>
</blockquote>
<h4 id='animated-images' class='heading'>Animated Images</h4>

<p>Nuke extends <code>UIImage</code> with <code>animatedImageData</code> property. If you enable it by setting <code><a href="Classes/ImagePipeline/Configuration.html#/s:4Nuke13ImagePipelineC13ConfigurationV010isAnimatedB11DataEnabledSbvpZ">ImagePipeline.Configuration.isAnimatedImageDataEnabled</a></code> to <code>true</code> the pipeline will start attaching original image data to the animated images (built-in decoder only supports GIFs for now).</p>

<blockquote>
<p><code><a href="Classes/ImageCache.html">ImageCache</a></code> takes  <code>animatedImageData</code> into account when computing the cost of cached items. <code><a href="Classes/ImagePipeline.html">ImagePipeline</a></code> doesn&rsquo;t apply processors to the images with animated data.</p>
</blockquote>

<p>There is no built-in way to render those images, but there are two integrations available: <a href="https://github.com/kean/Nuke-FLAnimatedImage-Plugin">FLAnimatedImage</a> and <a href="https://github.com/kean/Nuke-Gifu-Plugin">Gifu</a> which are both fast and efficient.</p>

<blockquote>
<p><code>GIF</code> is not the most efficient format for transferring and displaying animated images. The current best practice is to <a href="https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/replace-animated-gifs-with-video/">use short videos instead of GIFs</a> (e.g. <code>MP4</code>, <code>WebM</code>). There is a PoC available in the demo project which uses Nuke to load, cache and display an <code>MP4</code> video.</p>
</blockquote>
<h4 id='webp' class='heading'>WebP</h4>

<p>WebP support is provided by <a href="https://github.com/ryokosuge/Nuke-WebP-Plugin">Nuke WebP Plugin</a> built by <a href="https://github.com/ryokosuge">Ryo Kosuge</a>. Please follow the intructions from the repo to install it.</p>
<h4 id='rxnuke' class='heading'>RxNuke</h4>

<p><a href="https://github.com/kean/RxNuke">RxNuke</a> adds <a href="https://github.com/ReactiveX/RxSwift">RxSwift</a> extensions for Nuke and enables many common use cases:</p>

<ul>
<li><a href="https://github.com/kean/RxNuke#going-from-low-to-high-resolution">Going from low to high resolution</a></li>
<li><a href="https://github.com/kean/RxNuke#loading-the-first-available-image">Loading the first available image</a></li>
<li><a href="https://github.com/kean/RxNuke#showing-stale-image-while-validating-it">Showing stale image while validating it</a></li>
<li><a href="https://github.com/kean/RxNuke#load-multiple-images-display-all-at-once">Load multiple images, display all at once</a></li>
<li><a href="https://github.com/kean/RxNuke#auto-retry">Auto retry on failures</a></li>
<li>And <a href="https://github.com/kean/RxNuke#use-cases">more&hellip;</a></li>
</ul>

<p>Here&rsquo;s an example of how easy it is to load go flow log to high resolution:</p>
<pre class="highlight swift"><code><span class="k">let</span> <span class="nv">pipeline</span> <span class="o">=</span> <span class="kt">ImagePipeline</span><span class="o">.</span><span class="n">shared</span>
<span class="kt">Observable</span><span class="o">.</span><span class="nf">concat</span><span class="p">(</span><span class="n">pipeline</span><span class="o">.</span><span class="nf">loadImage</span><span class="p">(</span><span class="nv">with</span><span class="p">:</span> <span class="n">lowResUrl</span><span class="p">)</span><span class="o">.</span><span class="n">orEmpty</span><span class="p">,</span>
                  <span class="n">pipeline</span><span class="o">.</span><span class="nf">loadImage</span><span class="p">(</span><span class="nv">with</span><span class="p">:</span> <span class="n">highResUtl</span><span class="p">)</span><span class="o">.</span><span class="n">orEmpty</span><span class="p">)</span>
    <span class="o">.</span><span class="nf">subscribe</span><span class="p">(</span><span class="nv">onNext</span><span class="p">:</span> <span class="p">{</span> <span class="n">imageView</span><span class="o">.</span><span class="n">image</span> <span class="o">=</span> <span class="nv">$0</span> <span class="p">})</span>
    <span class="o">.</span><span class="nf">disposed</span><span class="p">(</span><span class="nv">by</span><span class="p">:</span> <span class="n">disposeBag</span><span class="p">)</span>
</code></pre>

<p><a name="h_design"></a></p>
<h1 id='image-pipeline' class='heading'>Image Pipeline</h1>

<p>Nuke&rsquo;s image pipeline consists of roughly five stages which can be customized using the following protocols:</p>

<table><thead>
<tr>
<th>Protocol</th>
<th>Description</th>
</tr>
</thead><tbody>
<tr>
<td><code><a href="Protocols/DataLoading.html">DataLoading</a></code></td>
<td>Download (or return cached) image data</td>
</tr>
<tr>
<td><code><a href="Protocols/DataCaching.html">DataCaching</a></code></td>
<td>Custom data cache</td>
</tr>
<tr>
<td><code><a href="Protocols/ImageDecoding.html">ImageDecoding</a></code></td>
<td>Convert data into image objects</td>
</tr>
<tr>
<td><code><a href="Protocols/ImageProcessing.html">ImageProcessing</a></code></td>
<td>Apply image transformations</td>
</tr>
<tr>
<td><code><a href="Protocols/ImageCaching.html">ImageCaching</a></code></td>
<td>Store image into memory cache</td>
</tr>
</tbody></table>
<h3 id='default-image-pipeline' class='heading'>Default Image Pipeline</h3>

<p>The default image pipeline configuration looks like this:</p>
<pre class="highlight swift"><code><span class="kt">ImagePipeline</span> <span class="p">{</span>
    <span class="c1">// Shared image cache with a `sizeLimit` equal to ~20% of available RAM.</span>
    <span class="nv">$0</span><span class="o">.</span><span class="n">imageCache</span> <span class="o">=</span> <span class="kt">ImageCache</span><span class="o">.</span><span class="n">shared</span>

    <span class="c1">// Data loader with a `URLSessionConfiguration.default` but with a</span>
    <span class="c1">// custom shared URLCache instance:</span>
    <span class="c1">//</span>
    <span class="c1">// public static let sharedUrlCache = URLCache(</span>
    <span class="c1">//     memoryCapacity: 0,</span>
    <span class="c1">//     diskCapacity: 150 * 1024 * 1024, // 150 MB</span>
    <span class="c1">//     diskPath: "com.github.kean.Nuke.Cache"</span>
    <span class="c1">//  )</span>
    <span class="nv">$0</span><span class="o">.</span><span class="n">dataLoader</span> <span class="o">=</span> <span class="kt">DataLoader</span><span class="p">()</span>

    <span class="c1">// Custom disk cache is disabled by default, the native URL cache used</span>
    <span class="c1">// by a `DataLoader` is used instead.</span>
    <span class="nv">$0</span><span class="o">.</span><span class="n">dataCache</span> <span class="o">=</span> <span class="kc">nil</span>

    <span class="c1">// Each stage is executed on a dedicated queue with has its own limits.</span>
    <span class="nv">$0</span><span class="o">.</span><span class="n">dataLoadingQueue</span><span class="o">.</span><span class="n">maxConcurrentOperationCount</span> <span class="o">=</span> <span class="mi">6</span>
    <span class="nv">$0</span><span class="o">.</span><span class="n">imageDecodingQueue</span><span class="o">.</span><span class="n">maxConcurrentOperationCount</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="nv">$0</span><span class="o">.</span><span class="n">imageProcessingQueue</span><span class="o">.</span><span class="n">maxConcurrentOperationCount</span> <span class="o">=</span> <span class="mi">2</span>

    <span class="c1">// Combine the requests for the same original image into one.</span>
    <span class="nv">$0</span><span class="o">.</span><span class="n">isDeduplicationEnabled</span> <span class="o">=</span> <span class="kc">true</span>

    <span class="c1">// Progressive decoding is a resource intensive feature so it is</span>
    <span class="c1">// disabled by default.</span>
    <span class="nv">$0</span><span class="o">.</span><span class="n">isProgressiveDecodingEnabled</span> <span class="o">=</span> <span class="kc">false</span>
<span class="p">}</span>
</code></pre>
<h3 id='image-pipeline-overview' class='heading'>Image Pipeline Overview</h3>

<p>Here&rsquo;s what happens when you call <code>Nuke.loadImage(with: url, into: imageView</code> method.</p>

<p>First, Nuke synchronously checks if the image is available in the memory cache (<code>pipeline.configuration.imageCache</code>). If it&rsquo;s not, Nuke calls <code>pipeline.loadImage(with: request)</code> method. The pipeline also checks if the image is available in its memory cache, and if not, starts loading it.</p>

<p>Before starting to load image data, the pipeline also checks whether there are any existing outstanding requests for the same image. If it finds one, no new requests are created.</p>

<p>By default, the data is loaded using <a href="https://developer.apple.com/reference/foundation/nsurlsession"><code>URLSession</code></a> with a custom <a href="https://developer.apple.com/reference/foundation/urlcache"><code>URLCache</code></a> instance (see configuration above). The <code>URLCache</code> supports on-disk caching but it requires HTTP cache to be enabled.</p>

<blockquote>
<p>See <a href="https://kean.github.io/post/image-caching">Image Caching Guide</a> to learn more.</p>
</blockquote>

<p>When the data is loaded the pipeline decodes the data (creates <code>UIImage</code> object from <code>Data</code>). Then it applies a default image processor - <code><a href="Structs/ImageDecompressor.html">ImageDecompressor</a></code> - to force data decompression in a background. The processed image is then stored in the memory cache and returned in the completion closure.</p>

<blockquote>
<p>When you create <code>UIImage</code> object form data, the data doesn&rsquo;t get decoded immediately. It&rsquo;s decoded the first time it&rsquo;s used - for example, when you display the image in an image view. Decoding is a resource-intensive operation, if you do it on the main thread you might see dropped frames, especially for image formats like JPEG.</p>

<p>To prevent decoding happening on the main thread, Nuke perform it in a background for you. But for even better performance it&rsquo;s recommended to downsample the images. To do so create a request with a target view size:</p>
<pre class="highlight plaintext"><code>ImageRequest(url: url, targetSize: CGSize(width: 640, height: 320), contentMode: .aspectFill)
</code></pre>

<p><strong>Warning:</strong> target size is in pixels!</p>

<p>See <a href="https://developer.apple.com/videos/play/wwdc2018/219">Image and Graphics Best Practices</a> to learn more about image decoding and downsampling.</p>
</blockquote>
<h3 id='data-loading-and-caching' class='heading'>Data Loading and Caching</h3>

<p>A built-in <code><a href="Classes/DataLoader.html">DataLoader</a></code> class implements <code><a href="Protocols/DataLoading.html">DataLoading</a></code> protocol and uses <a href="https://developer.apple.com/reference/foundation/nsurlsession"><code>URLSession</code></a> to load image data. The data is cached on disk using a <a href="https://developer.apple.com/reference/foundation/urlcache"><code>URLCache</code></a> instance, which by default is initialized with a memory capacity of 0 MB (Nuke stores images in memory, not image data) and a disk capacity of 150 MB.</p>

<p>The <code>URLSession</code> class natively supports the <code>data</code>, <code>file</code>, <code>ftp</code>, <code>http</code>, and <code>https</code> URL schemes. Image pipeline can be used with any of those schemes as well.</p>

<blockquote>
<p>See <a href="https://kean.github.io/post/image-caching">Image Caching Guide</a> to learn more about image caching</p>

<p>See <a href="https://github.com/kean/Nuke/blob/master/Documentation/Guides/Third%20Party%20Libraries.md#using-other-caching-libraries">Third Party Libraries</a> guide to learn how to use a custom data loader or cache</p>
</blockquote>

<p>Most developers either implement their own networking layer or use a third-party framework. Nuke supports both of those workflows. You can integrate your custom networking layer by implementing <code><a href="Protocols/DataLoading.html">DataLoading</a></code> protocol.</p>

<blockquote>
<p>See <a href="https://github.com/kean/Nuke-Alamofire-Plugin">Alamofire Plugin</a> that implements <code><a href="Protocols/DataLoading.html">DataLoading</a></code> protocol using <a href="https://github.com/Alamofire/Alamofire">Alamofire</a> framework</p>
</blockquote>
<h3 id='memory-cache' class='heading'>Memory Cache</h3>

<p>Processed images which are ready to be displayed are stored in a fast in-memory cache (<code><a href="Classes/ImageCache.html">ImageCache</a></code>). It uses <a href="https://en.wikipedia.org/wiki/Cache_algorithms#Examples">LRU (least recently used)</a> replacement algorithm and has a limit which prevents it from using more than ~20% of available RAM. As a good citizen, <code><a href="Classes/ImageCache.html">ImageCache</a></code> automatically evicts images on memory warnings and removes most of the images when the application enters background.</p>
<h3 id='resumable-downloads' class='heading'>Resumable Downloads</h3>

<p>If the data task is terminated (either because of a failure or a cancelation) and the image was partially loaded, the next load will resume where it was left off. </p>

<p>Resumable downloads require server to support <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Range_requests">HTTP Range Requests</a>. Nuke supports both validators (<code>ETag</code> and <code>Last-Modified</code>). The resumable downloads are enabled by default.</p>

<blockquote>
<p>By default resumable data is stored in an efficient memory cache. Future versions might include more customization.</p>
</blockquote>
<h3 id='request-dedupication' class='heading'>Request Dedupication</h3>

<p>By default <code><a href="Classes/ImagePipeline.html">ImagePipeline</a></code> combines the requests for the same image (but can be different processors) into the same task. The task&rsquo;s priority is set to the highest priority of registered requests and gets updated when requests are added or removed to the task. The task only gets canceled when all the registered requests are.</p>

<blockquote>
<p>Deduplication can be disabled using <code><a href="Classes/ImagePipeline/Configuration.html">ImagePipeline.Configuration</a></code>.</p>
</blockquote>

<p><a name="h_performance"></a></p>
<h1 id='performance' class='heading'>Performance</h1>

<p>Performance is one of the key differentiating factors for Nuke.</p>

<p>The framework is tuned to do as little work on the main thread as possible. It uses multiple optimizations techniques to achieve that: reducing number of allocations, reducing dynamic dispatch, backing some structs by reference typed storage to reduce ARC overhead, etc.</p>

<p>Nuke is fully asynchronous and works great under stress. <code><a href="Classes/ImagePipeline.html">ImagePipeline</a></code> schedules each of its stages on a dedicated queue. Each queue limits the number of concurrent tasks, respect request priorities even when moving between queue, and cancels the work as soon as possible. Under certain loads, <code><a href="Classes/ImagePipeline.html">ImagePipeline</a></code> will also rate limit the requests to prevent trashing of the underlying systems.</p>

<p>Another important performance characteristic is memory usage. Nuke uses a custom memory cache with <a href="https://en.wikipedia.org/wiki/Cache_algorithms#Examples">LRU (least recently used)</a> replacement algorithm. It has a limit which prevents it from using more than ~20% of available RAM. As a good citizen, <code><a href="Classes/ImageCache.html">ImageCache</a></code> automatically evicts images on memory warnings and removes most of the images when the application enters background.</p>
<h3 id='performance-metrics-beta' class='heading'>Performance Metrics (Beta)</h3>

<p>When optimizing performance, it&rsquo;s important to measure. Nuke collects detailed performance metrics during the execution of each image task:</p>
<pre class="highlight swift"><code><span class="kt">ImagePipeline</span><span class="o">.</span><span class="n">shared</span><span class="o">.</span><span class="n">didFinishCollectingMetrics</span> <span class="o">=</span> <span class="p">{</span> <span class="n">task</span><span class="p">,</span> <span class="n">metrics</span> <span class="k">in</span>
    <span class="nf">print</span><span class="p">(</span><span class="n">metrics</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>

<p><img src="https://user-images.githubusercontent.com/1567433/39193766-8dfd81b2-47dc-11e8-86b3-f3f69dc73d3a.png" alt="timeline"></p>
<pre class="highlight plaintext"><code>(lldb) po metrics

Task Information {
    Task ID - 1
    Duration - 22:35:16.123 – 22:35:16.475 (0.352s)
    Was canceled - false
    Is Memory Cache Hit - false
    Was Subscribed To Existing Session - false
}
Session Information {
    Session ID - 1
    Total Duration - 0.351s
    Was Canceled - false
}
Timeline {
    22:35:16.124 – 22:35:16.475 (0.351s) - Total
    ------------------------------------
    nil – nil (nil)                      - Check Disk Cache
    22:35:16.131 – 22:35:16.410 (0.278s) - Load Data
    22:35:16.410 – 22:35:16.468 (0.057s) - Decode
    22:35:16.469 – 22:35:16.474 (0.005s) - Process
}
Resumable Data {
    Was Resumed - nil
    Resumable Data Count - nil
    Server Confirmed Resume - nil
}
</code></pre>

<p><a name="h_plugins"></a></p>
<h1 id='extensions' class='heading'>Extensions</h1>

<p>There are a variety extensions available for Nuke some of which are built by the community.</p>

<table><thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead><tbody>
<tr>
<td><a href="https://github.com/kean/RxNuke"><strong>RxNuke</strong></a></td>
<td><a href="https://github.com/ReactiveX/RxSwift">RxSwift</a> extensions for Nuke with examples of common use cases solved by Rx</td>
</tr>
<tr>
<td><a href="https://github.com/kean/Nuke-Alamofire-Plugin"><strong>Alamofire</strong></a></td>
<td>Replace networking layer with <a href="https://github.com/Alamofire/Alamofire">Alamofire</a> and combine the power of both frameworks</td>
</tr>
<tr>
<td><a href="https://github.com/ryokosuge/Nuke-WebP-Plugin"><strong>WebP</strong></a></td>
<td><strong>[Community]</strong> <a href="https://developers.google.com/speed/webp/">WebP</a> support, built by <a href="https://github.com/ryokosuge">Ryo Kosuge</a></td>
</tr>
<tr>
<td><a href="https://github.com/kean/Nuke-Gifu-Plugin"><strong>Gifu</strong></a></td>
<td>Use <a href="https://github.com/kaishin/Gifu">Gifu</a> to load and display animated GIFs</td>
</tr>
<tr>
<td><a href="https://github.com/kean/Nuke-AnimatedImage-Plugin"><strong>FLAnimatedImage</strong></a></td>
<td>Use <a href="https://github.com/Flipboard/FLAnimatedImage">FLAnimatedImage</a> to load and display <a href="(https://www.youtube.com/watch?v=fEJqQMJrET4)">animated GIFs</a></td>
</tr>
</tbody></table>

<p><a name="h_contribute"></a></p>
<h1 id='contribution' class='heading'>Contribution</h1>

<p><a href="https://trello.com/b/Us4rHryT/nuke">Nuke&rsquo;s roadmap</a> is managed in Trello and is publically available.</p>

<p>If you&rsquo;d like to contribute, please feel free to create a PR.</p>

<p><a name="h_requirements"></a></p>
<h1 id='requirements' class='heading'>Requirements</h1>

<ul>
<li>iOS 9.0 / watchOS 2.0 / macOS 10.10 / tvOS 9.0</li>
<li>Xcode 9.2 - Xcode 10</li>
<li>Swift 4.0 - Swift 4.2</li>
</ul>
<h1 id='license' class='heading'>License</h1>

<p>Nuke is available under the MIT license. See the LICENSE file for more info.</p>

          </section>
        </section>
        <section id="footer">
          <p>&copy; 2018 <a class="link" href="https://github.com/kean" target="_blank" rel="external">kean</a>. All rights reserved. (Last updated: 2018-06-29)</p>
          <p>Generated by <a class="link" href="https://github.com/realm/jazzy" target="_blank" rel="external">jazzy ♪♫ v0.9.3</a>, a <a class="link" href="https://realm.io" target="_blank" rel="external">Realm</a> project.</p>
        </section>
      </article>
    </div>
  </body>
</div>
</html>
