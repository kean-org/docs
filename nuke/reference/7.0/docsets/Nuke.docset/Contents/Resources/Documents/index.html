<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Nuke  Reference</title>
    <link rel="stylesheet" type="text/css" href="css/jazzy.css" />
    <link rel="stylesheet" type="text/css" href="css/highlight.css" />
    <meta charset='utf-8'>
    <script src="js/jquery.min.js" defer></script>
    <script src="js/jazzy.js" defer></script>
    
  </head>
  <body>
    <a title="Nuke  Reference"></a>
    <header>
      <div class="content-wrapper">
        <p><a href="index.html">Nuke Docs</a> (73% documented)</p>
        <p class="header-right"><a href="https://github.com/kean/nuke"><img src="img/gh.png"/>View on GitHub</a></p>
      </div>
    </header>
    <div class="content-wrapper">
      <p id="breadcrumbs">
        <a href="index.html">Nuke Reference</a>
        <img id="carat" src="img/carat.png" />
        Nuke  Reference
      </p>
    </div>
    <div class="content-wrapper">
      <nav class="sidebar">
        <ul class="nav-groups">
          <li class="nav-group-name">
            <a href="Classes.html">Classes</a>
            <ul class="nav-group-tasks">
              <li class="nav-group-task">
                <a href="Classes/DataLoader.html">DataLoader</a>
              </li>
              <li class="nav-group-task">
                <a href="Classes/DataLoader/Error.html">– Error</a>
              </li>
              <li class="nav-group-task">
                <a href="Classes/ImageCache.html">ImageCache</a>
              </li>
              <li class="nav-group-task">
                <a href="Classes/ImageDecoder.html">ImageDecoder</a>
              </li>
              <li class="nav-group-task">
                <a href="Classes/ImageDecoderRegistry.html">ImageDecoderRegistry</a>
              </li>
              <li class="nav-group-task">
                <a href="Classes/ImagePipeline.html">ImagePipeline</a>
              </li>
              <li class="nav-group-task">
                <a href="Classes/ImagePipeline/Configuration.html">– Configuration</a>
              </li>
              <li class="nav-group-task">
                <a href="Classes/ImagePipeline/Error.html">– Error</a>
              </li>
              <li class="nav-group-task">
                <a href="Classes/ImagePreheater.html">ImagePreheater</a>
              </li>
              <li class="nav-group-task">
                <a href="Classes/ImageResponse.html">ImageResponse</a>
              </li>
              <li class="nav-group-task">
                <a href="Classes/ImageTask.html">ImageTask</a>
              </li>
            </ul>
          </li>
          <li class="nav-group-name">
            <a href="Extensions.html">Extensions</a>
            <ul class="nav-group-tasks">
              <li class="nav-group-task">
                <a href="Extensions/Image.html">Image</a>
              </li>
              <li class="nav-group-task">
                <a href="Extensions/NSImageView.html">NSImageView</a>
              </li>
              <li class="nav-group-task">
                <a href="Extensions/UIImageView.html">UIImageView</a>
              </li>
            </ul>
          </li>
          <li class="nav-group-name">
            <a href="Functions.html">Functions</a>
            <ul class="nav-group-tasks">
              <li class="nav-group-task">
                <a href="Functions.html#/s:4Nuke13cancelRequestyAA15ImageDisplaying_So6UIViewCXc3for_tF">cancelRequest(for:)</a>
              </li>
              <li class="nav-group-task">
                <a href="Functions.html#/s:4Nuke9loadImageAA0C4TaskCSg10Foundation3URLV4with_AA0C14LoadingOptionsV7optionsAA0C10Displaying_So6UIViewCXc4intoyAA0C8ResponseCSg_s5Int64VAUtcSg8progressyAS_AA0C8PipelineC5ErrorOSgtcSg10completiontF">loadImage(with:options:into:progress:completion:)</a>
              </li>
              <li class="nav-group-task">
                <a href="Functions.html#/s:4Nuke9loadImageAA0C4TaskCSgAA0C7RequestV4with_AA0C14LoadingOptionsV7optionsAA0C10Displaying_So6UIViewCXc4intoyAA0C8ResponseCSg_s5Int64VATtcSg8progressyAR_AA0C8PipelineC5ErrorOSgtcSg10completiontF">loadImage(with:options:into:progress:completion:)</a>
              </li>
            </ul>
          </li>
          <li class="nav-group-name">
            <a href="Protocols.html">Protocols</a>
            <ul class="nav-group-tasks">
              <li class="nav-group-task">
                <a href="Protocols/Cancellable.html">Cancellable</a>
              </li>
              <li class="nav-group-task">
                <a href="Protocols/DataLoading.html">DataLoading</a>
              </li>
              <li class="nav-group-task">
                <a href="Protocols/ImageCaching.html">ImageCaching</a>
              </li>
              <li class="nav-group-task">
                <a href="Protocols/ImageDecoding.html">ImageDecoding</a>
              </li>
              <li class="nav-group-task">
                <a href="Protocols/ImageDisplaying.html">ImageDisplaying</a>
              </li>
              <li class="nav-group-task">
                <a href="Protocols/ImageProcessing.html">ImageProcessing</a>
              </li>
            </ul>
          </li>
          <li class="nav-group-name">
            <a href="Structs.html">Structures</a>
            <ul class="nav-group-tasks">
              <li class="nav-group-task">
                <a href="Structs/AnyImageProcessor.html">AnyImageProcessor</a>
              </li>
              <li class="nav-group-task">
                <a href="Structs/ImageDecodingContext.html">ImageDecodingContext</a>
              </li>
              <li class="nav-group-task">
                <a href="Structs/ImageDecompressor.html">ImageDecompressor</a>
              </li>
              <li class="nav-group-task">
                <a href="Structs/ImageDecompressor/ContentMode.html">– ContentMode</a>
              </li>
              <li class="nav-group-task">
                <a href="Structs/ImageLoadingOptions.html">ImageLoadingOptions</a>
              </li>
              <li class="nav-group-task">
                <a href="Structs/ImageLoadingOptions/ContentModes.html">– ContentModes</a>
              </li>
              <li class="nav-group-task">
                <a href="Structs/ImageLoadingOptions/Transition.html">– Transition</a>
              </li>
              <li class="nav-group-task">
                <a href="Structs/ImageProcessingContext.html">ImageProcessingContext</a>
              </li>
              <li class="nav-group-task">
                <a href="Structs/ImageRequest.html">ImageRequest</a>
              </li>
              <li class="nav-group-task">
                <a href="Structs/ImageRequest/MemoryCacheOptions.html">– MemoryCacheOptions</a>
              </li>
              <li class="nav-group-task">
                <a href="Structs/ImageRequest/Priority.html">– Priority</a>
              </li>
              <li class="nav-group-task">
                <a href="Structs/ImageTaskMetrics.html">ImageTaskMetrics</a>
              </li>
              <li class="nav-group-task">
                <a href="Structs/ImageTaskMetrics/SessionMetrics.html">– SessionMetrics</a>
              </li>
            </ul>
          </li>
          <li class="nav-group-name">
            <a href="Typealiases.html">Type Aliases</a>
            <ul class="nav-group-tasks">
              <li class="nav-group-task">
                <a href="Typealiases.html#/Image">Image</a>
              </li>
              <li class="nav-group-task">
                <a href="Typealiases.html#/s:4Nuke5Imagea">Image</a>
              </li>
              <li class="nav-group-task">
                <a href="Typealiases.html#/ImageDisplayingView">ImageDisplayingView</a>
              </li>
              <li class="nav-group-task">
                <a href="Typealiases.html#/s:4Nuke19ImageDisplayingViewa">ImageDisplayingView</a>
              </li>
            </ul>
          </li>
        </ul>
      </nav>
      <article class="main-content">
        <section>
          <section class="section">
            
            <p align="center"><img src="https://cloud.githubusercontent.com/assets/1567433/13918338/f8670eea-ef7f-11e5-814d-f15bdfd6b2c0.png" height="180"/>

<p align="center">
<img src="https://img.shields.io/cocoapods/v/Nuke.svg?label=version">
<img src="https://img.shields.io/badge/supports-CocoaPods%20%7C%20Carthage%20%7C%20SwiftPM-green.svg">
<img src="https://img.shields.io/badge/platforms-iOS%20%7C%20macOS%20%7C%20watchOS%20%7C%20tvOS-lightgrey.svg">
<a href="https://travis-ci.org/kean/Nuke"><img src="https://img.shields.io/travis/kean/Nuke/master.svg"></a>
</p>

<p>A powerful <strong>image loading</strong> and <strong>caching</strong> system. It makes simple tasks like loading images into views extremely simple, while also supporting more advanced features for more demanding apps.</p>

<ul>
<li>Two <a href="https://kean.github.io/post/image-caching">cache layers</a>, fast LRU disk and memory caches</li>
<li>Progressive image loading (progressive JPEG and WebP)</li>
<li>Resumable downloads, request deduplication, prioritization, rate limiting and more</li>
<li><a href="https://github.com/kean/Nuke-Alamofire-Plugin">Alamofire</a>, <a href="https://github.com/ryokosuge/Nuke-WebP-Plugin">WebP</a>, <a href="https://github.com/kean/Nuke-Gifu-Plugin">Gifu</a>, <a href="https://github.com/kean/Nuke-FLAnimatedImage-Plugin">FLAnimatedImage</a> extensions</li>
<li><a href="https://github.com/kean/RxNuke">RxNuke</a> - <a href="https://github.com/ReactiveX/RxSwift">RxSwift</a> extensions</li>
<li>Automates <a href="https://kean.github.io/post/image-preheating">prefetching</a> with <a href="https://github.com/kean/Preheat">Preheat</a> (<em>deprecated in iOS 10</em>)</li>
</ul>
<h1 id='a-name-h_getting_started-a-quick-start' class='heading'><a name="h_getting_started"></a>Quick Start</h1>

<blockquote>
<p>Upgrading from the previous version? Use a <a href="https://github.com/kean/Nuke/blob/master/Documentation/Migrations"><strong>Migration Guide</strong></a>.</p>
</blockquote>

<ul>
<li>Basic <a href="#h_usage"><strong>Usage Guide</strong></a>, best place to start

<ul>
<li><a href="#load-image-into-image-view">Load Image into Image View</a></li>
<li><a href="#placeholders-transitions-and-more">Placeholders, Transitions and More</a></li>
<li><a href="#image-requests">Image Requests</a>, <a href="#process-an-image">Process an Image</a></li>
<li><a href="#image-pipeline">Image Pipeline</a>, <a href="#configuring-image-pipeline">Configuring Image Pipeline</a></li>
</ul></li>
<li><a href="#advanced-usage"><strong>Advanced Usage Guide</strong></a>

<ul>
<li><a href="#memory-cache">Memory Cache</a>, <a href="#http-disk-cache">HTTP Disk Cache</a>, <a href="#aggressive-disk-cache-experimental">Aggressive Disk Cache (Beta)</a></li>
<li><a href="#preheat-images">Preheat Images</a></li>
<li><a href="#progressive-decoding">Progressive Decoding</a>, <a href="#webp">WebP</a></li>
<li><a href="#rxnuke">RxNuke</a></li>
</ul></li>
<li>Detailed <a href="#h_design"><strong>Image Pipeline</strong></a> description</li>
<li>Entire section dedicated to <a href="#h_performance"><strong>Performance</strong></a></li>
<li>List of <a href="#h_plugins"><strong>Extensions</strong></a>, both official and built by the community</li>
<li><a href="#h_requirements"><strong>Requirements</strong></a></li>
</ul>

<p>More information is available in <a href="https://github.com/kean/Nuke/blob/master/Documentation/"><strong>Documentation</strong></a> directory and a full <a href="https://kean.github.io/Nuke/reference/7.0-rc1/index.html"><strong>API Reference</strong></a>. When you are ready to install Nuke you can follow an <a href="https://github.com/kean/Nuke/blob/master/Documentation/Guides/Installation%20Guide.md"><strong>Installation Guide</strong></a> - all major package managers are supported.</p>
<h1 id='a-name-h_usage-a-usage' class='heading'><a name="h_usage"></a>Usage</h1>
<h4 id='load-image-into-image-view' class='heading'>Load Image into Image View</h4>

<p>You can load an image into an image view with a single line of code:</p>
<pre class="highlight swift"><code><span class="kt">Nuke</span><span class="o">.</span><span class="nf">loadImage</span><span class="p">(</span><span class="nv">with</span><span class="p">:</span> <span class="n">url</span><span class="p">,</span> <span class="nv">into</span><span class="p">:</span> <span class="n">imageView</span><span class="p">)</span>
</code></pre>

<p>Nuke will automatically load image data, decompress it in the background, store image in memory cache and display it.</p>

<blockquote>
<p>To learn more about the image pipeline <a href="#h_design">see the dedicated section</a>.</p>
</blockquote>

<p>Nuke keeps track of each image view. When you request a new image for a view the previous outstanding request gets cancelled. The same happens automatically when the view is deallocated.</p>
<pre class="highlight swift"><code><span class="kd">func</span> <span class="nf">collectionView</span><span class="p">(</span><span class="n">_</span> <span class="nv">collectionView</span><span class="p">:</span> <span class="kt">UICollectionView</span><span class="p">,</span> <span class="n">cellForItemAt</span> <span class="nv">indexPath</span><span class="p">:</span> <span class="kt">IndexPath</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">UICollectionViewCell</span> <span class="p">{</span>
    <span class="o">...</span>
    <span class="c1">// Previous request for the image view gets cancelled. The view is</span>
    <span class="c1">// automatically prepared for reuse (image set to `nil`).</span>
    <span class="kt">Nuke</span><span class="o">.</span><span class="nf">loadImage</span><span class="p">(</span><span class="nv">with</span><span class="p">:</span> <span class="n">url</span><span class="p">,</span> <span class="nv">into</span><span class="p">:</span> <span class="n">cell</span><span class="o">.</span><span class="n">imageView</span><span class="p">)</span>
    <span class="o">...</span>
<span class="p">}</span>
</code></pre>
<h4 id='placeholders-transitions-and-more' class='heading'>Placeholders, Transitions and More</h4>

<p>You can use an  <code>options</code> parameter (<code><a href="Structs/ImageLoadingOptions.html">ImageLoadingOptions</a></code>)  to customize the way images are loaded and displayed. You can provide a placeholder, select one of the built-in transitions or provide a custom one:</p>
<pre class="highlight swift"><code><span class="kt">Nuke</span><span class="o">.</span><span class="nf">loadImage</span><span class="p">(</span>
    <span class="nv">with</span><span class="p">:</span> <span class="n">url</span><span class="p">,</span>
    <span class="nv">options</span><span class="p">:</span> <span class="kt">ImageLoadingOptions</span><span class="p">(</span>
        <span class="nv">placeholder</span><span class="p">:</span> <span class="kt">UIImage</span><span class="p">(</span><span class="nv">named</span><span class="p">:</span> <span class="s">"placeholder"</span><span class="p">),</span>
        <span class="nv">transition</span><span class="p">:</span> <span class="o">.</span><span class="nf">fadeIn</span><span class="p">(</span><span class="mf">0.33</span><span class="p">)</span>
    <span class="p">),</span>
    <span class="nv">into</span><span class="p">:</span> <span class="n">imageView</span>
<span class="p">)</span>
</code></pre>

<p>There is also a very common scenario when the placeholder (or the failure image) needs to be displayed with a content mode different from the one used for the loaded image. <code><a href="Structs/ImageLoadingOptions.html">ImageLoadingOptions</a></code> supports precisely that:</p>
<pre class="highlight swift"><code><span class="k">let</span> <span class="nv">options</span> <span class="o">=</span> <span class="kt">ImageLoadingOptions</span><span class="p">(</span>
    <span class="nv">placeholder</span><span class="p">:</span> <span class="kt">UIImage</span><span class="p">(</span><span class="nv">named</span><span class="p">:</span> <span class="s">"placeholder"</span><span class="p">),</span>
    <span class="nv">failureImage</span><span class="p">:</span> <span class="kt">UIImage</span><span class="p">(</span><span class="nv">named</span><span class="p">:</span> <span class="s">"failure_image"</span><span class="p">),</span>
    <span class="n">contentModes</span> <span class="o">=</span> <span class="o">.</span><span class="nf">init</span><span class="p">(</span>
        <span class="nv">success</span><span class="p">:</span> <span class="o">.</span><span class="n">scaleAspectFill</span><span class="p">,</span>
        <span class="nv">failure</span><span class="p">:</span> <span class="o">.</span><span class="n">center</span><span class="p">,</span>
        <span class="nv">placeholder</span><span class="p">:</span> <span class="o">.</span><span class="n">center</span>
    <span class="p">)</span>
<span class="p">)</span>

<span class="kt">Nuke</span><span class="o">.</span><span class="nf">loadImage</span><span class="p">(</span><span class="nv">with</span><span class="p">:</span> <span class="n">url</span><span class="p">,</span> <span class="nv">options</span><span class="p">:</span> <span class="n">options</span><span class="p">,</span> <span class="nv">into</span><span class="p">:</span> <span class="n">imageView</span><span class="p">)</span>
</code></pre>

<p>If you find yourself in a situation where you need some feature that is not implemented by <code><a href="Structs/ImageLoadingOptions.html">ImageLoadingOptions</a></code>, it might mean that you need to use <code><a href="Classes/ImagePipeline.html">ImagePipeline</a></code> directly to fetch an image and then display it. </p>

<blockquote>
<p>To make all image views in the app share the same behaviour modify <code><a href="Structs/ImageLoadingOptions.html#/s:4Nuke19ImageLoadingOptionsV6sharedACvpZ">ImageLoadingOptions.shared</a></code>.</p>
</blockquote>
<h4 id='image-requests' class='heading'>Image Requests</h4>

<p>Each request is represented by an <code><a href="Structs/ImageRequest.html">ImageRequest</a></code> struct. A request can be created with either <code>URL</code> or <code>URLRequest</code>.</p>
<pre class="highlight swift"><code><span class="k">var</span> <span class="nv">request</span> <span class="o">=</span> <span class="kt">ImageRequest</span><span class="p">(</span><span class="nv">url</span><span class="p">:</span> <span class="n">url</span><span class="p">)</span>
<span class="c1">// var request = ImageRequest(urlRequest: URLRequest(url: url))</span>

<span class="c1">// Change memory cache policy:</span>
<span class="n">request</span><span class="o">.</span><span class="n">memoryCacheOptions</span><span class="o">.</span><span class="n">isWriteAllowed</span> <span class="o">=</span> <span class="kc">false</span>

<span class="c1">// Update the request priority:</span>
<span class="n">request</span><span class="o">.</span><span class="n">priority</span> <span class="o">=</span> <span class="o">.</span><span class="n">high</span>

<span class="kt">Nuke</span><span class="o">.</span><span class="nf">loadImage</span><span class="p">(</span><span class="nv">with</span><span class="p">:</span> <span class="n">request</span><span class="p">,</span> <span class="nv">into</span><span class="p">:</span> <span class="n">imageView</span><span class="p">)</span>
</code></pre>
<h4 id='process-an-image' class='heading'>Process an Image</h4>

<p>Nuke can process images for you. The first option is to resize the image using a <code>Request</code>:</p>
<pre class="highlight swift"><code><span class="c1">/// Target size is in pixels.</span>
<span class="kt">ImageRequest</span><span class="p">(</span><span class="nv">url</span><span class="p">:</span> <span class="n">url</span><span class="p">,</span> <span class="nv">targetSize</span><span class="p">:</span> <span class="kt">CGSize</span><span class="p">(</span><span class="nv">width</span><span class="p">:</span> <span class="mi">640</span><span class="p">,</span> <span class="nv">height</span><span class="p">:</span> <span class="mi">320</span><span class="p">),</span> <span class="nv">contentMode</span><span class="p">:</span> <span class="o">.</span><span class="n">aspectFill</span><span class="p">)</span>
</code></pre>

<p>To perform a custom tranformation use a <code>processed(key:closure:)</code> method. Her&rsquo;s how to create a circular avatar using <a href="https://github.com/gavinbunney/Toucan">Toucan</a>:</p>
<pre class="highlight swift"><code><span class="kt">ImageRequest</span><span class="p">(</span><span class="nv">url</span><span class="p">:</span> <span class="n">url</span><span class="p">)</span><span class="o">.</span><span class="nf">process</span><span class="p">(</span><span class="nv">key</span><span class="p">:</span> <span class="s">"circularAvatar"</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">Toucan</span><span class="p">(</span><span class="nv">image</span><span class="p">:</span> <span class="nv">$0</span><span class="p">)</span><span class="o">.</span><span class="nf">maskWithEllipse</span><span class="p">()</span><span class="o">.</span><span class="n">image</span>
<span class="p">}</span>
</code></pre>

<p>All of those APIs are built on top of <code><a href="Protocols/ImageProcessing.html">ImageProcessing</a></code> protocol. If you&rsquo;d like to you can implement your own processors that adopt it. Keep in mind that <code><a href="Protocols/ImageProcessing.html">ImageProcessing</a></code> also requires <code>Equatable</code> conformance which helps Nuke identify images in memory cache.</p>

<blockquote>
<p>See <a href="https://github.com/kean/Nuke/blob/master/Documentation/Guides/Core%20Image%20Integration%20Guide.md">Core Image Integration Guide</a> for more info about using Core Image with Nuke</p>
</blockquote>
<h4 id='image-pipeline' class='heading'>Image Pipeline</h4>

<p>You can use <code><a href="Classes/ImagePipeline.html">ImagePipeline</a></code> to load images directly without a view. <code><a href="Classes/ImagePipeline.html">ImagePipeline</a></code> offers a convenience closure-based API for loading images:</p>
<pre class="highlight swift"><code><span class="k">let</span> <span class="nv">task</span> <span class="o">=</span> <span class="kt">ImagePipeline</span><span class="o">.</span><span class="n">shared</span><span class="o">.</span><span class="nf">loadImage</span><span class="p">(</span>
    <span class="nv">with</span><span class="p">:</span> <span class="n">url</span><span class="p">,</span>
    <span class="nv">progress</span><span class="p">:</span> <span class="p">{</span> <span class="n">_</span><span class="p">,</span> <span class="n">completed</span><span class="p">,</span> <span class="n">total</span> <span class="k">in</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"progress updated"</span><span class="p">)</span>
    <span class="p">},</span>
    <span class="nv">completion</span><span class="p">:</span> <span class="p">{</span> <span class="n">response</span><span class="p">,</span> <span class="n">error</span> <span class="k">in</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"task completed"</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">)</span>

<span class="c1">// task.cancel()</span>
<span class="c1">// task.setPriority(.high)</span>
</code></pre>

<p>Tasks can be used to track download progress, cancel the requests, and dynamically udpdate download priority.</p>
<h4 id='configuring-image-pipeline' class='heading'>Configuring Image Pipeline</h4>

<p><code><a href="Classes/ImagePipeline.html">ImagePipeline</a></code> is initialized with a <code>Configuration</code> which makes it fully customizable:</p>
<pre class="highlight swift"><code><span class="k">let</span> <span class="nv">pipeline</span> <span class="o">=</span> <span class="kt">ImagePipeline</span> <span class="p">{</span>
    <span class="nv">$0</span><span class="o">.</span><span class="n">dataLoader</span> <span class="o">=</span> <span class="cm">/* your data loader */</span>
    <span class="nv">$0</span><span class="o">.</span><span class="n">dataLoadingQueue</span> <span class="o">=</span> <span class="kt">OperationQueue</span><span class="p">()</span> <span class="cm">/* your custom download queue */</span>
    <span class="nv">$0</span><span class="o">.</span><span class="n">imageCache</span> <span class="o">=</span> <span class="cm">/* your image cache */</span>
    <span class="cm">/* etc... */</span>
<span class="p">}</span>

<span class="c1">// When you're done you can make the pipeline a shared one:</span>
<span class="kt">ImagePipeline</span><span class="o">.</span><span class="n">shared</span> <span class="o">=</span> <span class="n">pipeline</span>
</code></pre>
<h1 id='advanced-usage' class='heading'>Advanced Usage</h1>
<h4 id='memory-cache' class='heading'>Memory Cache</h4>

<p>Default Nuke&rsquo;s <code><a href="Classes/ImagePipeline.html">ImagePipeline</a></code> has two cache layers.</p>

<p>First, there is a memory cache for storing processed images ready for display. You can get a direct access to this cache:</p>
<pre class="highlight swift"><code><span class="c1">// Configure cache</span>
<span class="kt">ImageCache</span><span class="o">.</span><span class="n">shared</span><span class="o">.</span><span class="n">costLimit</span> <span class="o">=</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">100</span> <span class="c1">// 100 MB</span>
<span class="kt">ImageCache</span><span class="o">.</span><span class="n">shared</span><span class="o">.</span><span class="n">countLimit</span> <span class="o">=</span> <span class="mi">100</span>
<span class="kt">ImageCache</span><span class="o">.</span><span class="n">shared</span><span class="o">.</span><span class="n">ttl</span> <span class="o">=</span> <span class="mi">120</span> <span class="c1">// Invalidate image after 120 sec</span>

<span class="c1">// Read and write images</span>
<span class="k">let</span> <span class="nv">request</span> <span class="o">=</span> <span class="kt">ImageRequest</span><span class="p">(</span><span class="nv">url</span><span class="p">:</span> <span class="n">url</span><span class="p">)</span>
<span class="kt">ImageCache</span><span class="o">.</span><span class="n">shared</span><span class="p">[</span><span class="n">request</span><span class="p">]</span> <span class="o">=</span> <span class="n">image</span>
<span class="k">let</span> <span class="nv">image</span> <span class="o">=</span> <span class="kt">ImageCache</span><span class="o">.</span><span class="n">shared</span><span class="p">[</span><span class="n">request</span><span class="p">]</span>

<span class="c1">// Clear cache</span>
<span class="kt">ImageCache</span><span class="o">.</span><span class="n">shared</span><span class="o">.</span><span class="nf">removeAll</span><span class="p">()</span>
</code></pre>
<h4 id='http-disk-cache' class='heading'>HTTP Disk Cache</h4>

<p>To store unprocessed image data Nuke uses a <code>URLCache</code> instance:</p>
<pre class="highlight swift"><code><span class="c1">// Configure cache</span>
<span class="kt">DataLoader</span><span class="o">.</span><span class="n">sharedUrlCache</span><span class="o">.</span><span class="n">diskCapacity</span> <span class="o">=</span> <span class="mi">100</span>
<span class="kt">DataLoader</span><span class="o">.</span><span class="n">sharedUrlCache</span><span class="o">.</span><span class="n">memoryCapacity</span> <span class="o">=</span> <span class="mi">0</span>

<span class="c1">// Read and write responses</span>
<span class="k">let</span> <span class="nv">request</span> <span class="o">=</span> <span class="kt">ImageRequest</span><span class="p">(</span><span class="nv">url</span><span class="p">:</span> <span class="n">url</span><span class="p">)</span>
<span class="k">let</span> <span class="nv">_</span> <span class="o">=</span> <span class="kt">DataLoader</span><span class="o">.</span><span class="n">sharedUrlCache</span><span class="o">.</span><span class="nf">cachedResponse</span><span class="p">(</span><span class="nv">for</span><span class="p">:</span> <span class="n">request</span><span class="o">.</span><span class="n">urlRequest</span><span class="p">)</span>
<span class="kt">DataLoader</span><span class="o">.</span><span class="n">sharedUrlCache</span><span class="o">.</span><span class="nf">removeCachedResponse</span><span class="p">(</span><span class="nv">for</span><span class="p">:</span> <span class="n">request</span><span class="o">.</span><span class="n">urlRequest</span><span class="p">)</span>

<span class="c1">// Clear cache</span>
<span class="kt">DataLoader</span><span class="o">.</span><span class="n">sharedUrlCache</span><span class="o">.</span><span class="nf">removeAllCachedResponses</span><span class="p">()</span>
</code></pre>
<h4 id='aggressive-disk-cache-experimental' class='heading'>Aggressive Disk Cache (Experimental)</h4>

<p>Add a completely new custom LRU disk cache which can be used for fast and reliable <em>aggressive</em> data caching (ignores <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control">HTTP cache control</a>). The new cache lookups are up to 2x faster than <code>URLCache</code> lookups. You can enable it using pipeline&rsquo;s configuration:</p>

<p>When enabling disk cache you must provide a <code>keyEncoder</code> function which takes image request&rsquo;s url as a parameter and produces a key which can be used as a valid filename. The <a href="https://gist.github.com/kean/f5e1975e01d5e0c8024bc35556665d7b">demo project uses sha1</a> to generate those keys.</p>
<pre class="highlight swift"><code><span class="nv">$0</span><span class="o">.</span><span class="nf">enableExperimentalAggressiveDiskCaching</span><span class="p">(</span><span class="nv">keyEncoder</span><span class="p">:</span> <span class="p">{</span>
    <span class="k">guard</span> <span class="k">let</span> <span class="nv">data</span> <span class="o">=</span> <span class="nv">$0</span><span class="o">.</span><span class="nf">cString</span><span class="p">(</span><span class="nv">using</span><span class="p">:</span> <span class="o">.</span><span class="n">utf8</span><span class="p">)</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">nil</span> <span class="p">}</span>
    <span class="k">return</span> <span class="nf">_nuke_sha1</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="kt">UInt32</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">count</span><span class="p">))</span>
<span class="p">})</span>
</code></pre>

<p>The public API for disk cache and the API for using custom disk caches is going to be available in the future versions.</p>

<blockquote>
<p>Existing API already allows you to use custom disk cache <a href="https://github.com/kean/Nuke/blob/master/Documentation/Guides/Third%20Party%20Libraries.md#using-other-caching-libraries">by implementing <code><a href="Protocols/DataLoading.html">DataLoading</a></code> protocol</a>, but this is not the most straightforward option.</p>
</blockquote>
<h4 id='preheat-images' class='heading'>Preheat Images</h4>

<p><a href="https://kean.github.io/post/image-preheating">Preheating</a> (prefetching) means loading images ahead of time in anticipation of their use. Nuke provides a <code><a href="Classes/ImagePreheater.html">ImagePreheater</a></code> class that does just that:</p>
<pre class="highlight swift"><code><span class="k">let</span> <span class="nv">preheater</span> <span class="o">=</span> <span class="kt">ImagePreheater</span><span class="p">(</span><span class="nv">pipeline</span><span class="p">:</span> <span class="kt">ImagePipeline</span><span class="o">.</span><span class="n">shared</span><span class="p">)</span>

<span class="k">let</span> <span class="nv">requests</span> <span class="o">=</span> <span class="n">urls</span><span class="o">.</span><span class="n">map</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">request</span> <span class="o">=</span> <span class="kt">ImageRequest</span><span class="p">(</span><span class="nv">url</span><span class="p">:</span> <span class="nv">$0</span><span class="p">)</span>
    <span class="n">request</span><span class="o">.</span><span class="n">priority</span> <span class="o">=</span> <span class="o">.</span><span class="n">low</span>
    <span class="k">return</span> <span class="n">request</span>
<span class="p">}</span>

<span class="c1">// User enters the screen:</span>
<span class="n">preheater</span><span class="o">.</span><span class="nf">startPreheating</span><span class="p">(</span><span class="nv">for</span><span class="p">:</span> <span class="n">requests</span><span class="p">)</span>

<span class="c1">// User leaves the screen:</span>
<span class="n">preheater</span><span class="o">.</span><span class="nf">stopPreheating</span><span class="p">(</span><span class="nv">for</span><span class="p">:</span> <span class="n">requests</span><span class="p">)</span>
</code></pre>

<p>You can use Nuke in combination with <a href="https://github.com/kean/Preheat">Preheat</a> library which automates preheating of content in <code>UICollectionView</code> and <code>UITableView</code>. On iOS 10.0 you might want to use new <a href="https://developer.apple.com/reference/uikit/uitableviewdatasourceprefetching">prefetching APIs</a> provided by iOS instead.</p>

<blockquote>
<p>Check out <a href="https://github.com/kean/Nuke/blob/master/Documentation/Guides/Performance%20Guide.md">Performance Guide</a> to see what else you can do to improve performance</p>
</blockquote>
<h4 id='progressive-decoding' class='heading'>Progressive Decoding</h4>

<p>To use progressive image loading you need a pipeline with progressive decoding enabled:</p>
<pre class="highlight swift"><code><span class="k">let</span> <span class="nv">pipeline</span> <span class="o">=</span> <span class="kt">ImagePipeline</span> <span class="p">{</span>
    <span class="nv">$0</span><span class="o">.</span><span class="n">isProgressiveDecodingEnabled</span> <span class="o">=</span> <span class="kc">true</span>
<span class="p">}</span>
</code></pre>

<p>And that&rsquo;s it, you can start observing images as they are produced by the pipeline. The progress handler also works as a progressive image handler:</p>
<pre class="highlight swift"><code><span class="k">let</span> <span class="nv">imageView</span> <span class="o">=</span> <span class="kt">UIImageView</span><span class="p">()</span>
<span class="k">let</span> <span class="nv">task</span> <span class="o">=</span> <span class="kt">ImagePipeline</span><span class="o">.</span><span class="n">shared</span><span class="o">.</span><span class="nf">loadImage</span><span class="p">(</span>
    <span class="nv">with</span><span class="p">:</span> <span class="n">url</span><span class="p">,</span>
    <span class="nv">progress</span><span class="p">:</span> <span class="p">{</span> <span class="n">image</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="k">in</span>
        <span class="k">guard</span> <span class="k">let</span> <span class="nv">image</span> <span class="o">=</span> <span class="n">image</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="p">}</span>
        <span class="n">imageView</span><span class="o">.</span><span class="n">image</span> <span class="o">=</span> <span class="n">image</span>
    <span class="p">},</span>
    <span class="nv">completion</span><span class="p">:</span> <span class="p">{</span> <span class="n">response</span><span class="p">,</span> <span class="n">_</span> <span class="k">in</span>
        <span class="k">guard</span> <span class="k">let</span> <span class="nv">image</span> <span class="o">=</span> <span class="n">response</span><span class="p">?</span><span class="o">.</span><span class="n">image</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="p">}</span>
        <span class="n">imageView</span><span class="o">.</span><span class="n">image</span> <span class="o">=</span> <span class="n">image</span>
    <span class="p">}</span>
<span class="p">)</span>
</code></pre>

<p>The progressive decoding only kicks in when Nuke determines that the image data does contain a progressive JPEG. The decoder scans the data and only produces a new image when it receives a full new scan (progressive JPEGs normally have around 10 scans).</p>

<blockquote>
<p>See <q>Progressive Decoding</q> demo to see progressive JPEG in practice. You can also uncomment the code that blurs the first few scans of the image which makes them look a bit nicer.</p>
</blockquote>
<h4 id='webp' class='heading'>WebP</h4>

<p>WebP support is provided by <a href="https://github.com/ryokosuge/Nuke-WebP-Plugin">Nuke WebP Plugin</a> built by <a href="https://github.com/ryokosuge">Ryo Kosuge</a>. Please follow the intructions from the repo to install it.</p>
<h4 id='rxnuke' class='heading'>RxNuke</h4>

<p><a href="https://github.com/kean/RxNuke">RxNuke</a> adds <a href="https://github.com/ReactiveX/RxSwift">RxSwift</a> extensions for Nuke and enables many common use cases:</p>

<ul>
<li><a href="https://github.com/kean/RxNuke#going-from-low-to-high-resolution">Going from low to high resolution</a></li>
<li><a href="https://github.com/kean/RxNuke#loading-the-first-available-image">Loading the first available image</a></li>
<li><a href="https://github.com/kean/RxNuke#showing-stale-image-while-validating-it">Showing stale image while validating it</a></li>
<li><a href="https://github.com/kean/RxNuke#load-multiple-images-display-all-at-once">Load multiple images, display all at once</a></li>
<li><a href="https://github.com/kean/RxNuke#auto-retry">Auto retry on failures</a></li>
<li>And <a href="https://github.com/kean/RxNuke#use-cases">more&hellip;</a></li>
</ul>

<p>Here&rsquo;s an example of how easy it is to load go flow log to high resolution:</p>
<pre class="highlight swift"><code><span class="k">let</span> <span class="nv">pipeline</span> <span class="o">=</span> <span class="kt">ImagePipeline</span><span class="o">.</span><span class="n">shared</span>
<span class="kt">Observable</span><span class="o">.</span><span class="nf">concat</span><span class="p">(</span><span class="n">pipeline</span><span class="o">.</span><span class="nf">loadImage</span><span class="p">(</span><span class="nv">with</span><span class="p">:</span> <span class="n">lowResUrl</span><span class="p">)</span><span class="o">.</span><span class="n">orEmpty</span><span class="p">,</span>
                  <span class="n">pipeline</span><span class="o">.</span><span class="nf">loadImage</span><span class="p">(</span><span class="nv">with</span><span class="p">:</span> <span class="n">highResUtl</span><span class="p">)</span><span class="o">.</span><span class="n">orEmpty</span><span class="p">)</span>
    <span class="o">.</span><span class="nf">subscribe</span><span class="p">(</span><span class="nv">onNext</span><span class="p">:</span> <span class="p">{</span> <span class="n">imageView</span><span class="o">.</span><span class="n">image</span> <span class="o">=</span> <span class="nv">$0</span> <span class="p">})</span>
    <span class="o">.</span><span class="nf">disposed</span><span class="p">(</span><span class="nv">by</span><span class="p">:</span> <span class="n">disposeBag</span><span class="p">)</span>
</code></pre>

<p><a name="h_design"></a></p>
<h1 id='image-pipeline' class='heading'>Image Pipeline</h1>

<p>Nuke&rsquo;s image pipeline consists of roughly five stages which can be customized using the following protocols:</p>

<table><thead>
<tr>
<th>Protocol</th>
<th>Description</th>
</tr>
</thead><tbody>
<tr>
<td><code><a href="Protocols/DataLoading.html">DataLoading</a></code></td>
<td>Download (or return cached) image data</td>
</tr>
<tr>
<td><code><a href="Protocols/ImageDecoding.html">ImageDecoding</a></code></td>
<td>Convert data into image objects</td>
</tr>
<tr>
<td><code><a href="Protocols/ImageProcessing.html">ImageProcessing</a></code></td>
<td>Apply image transformations</td>
</tr>
<tr>
<td><code><a href="Protocols/ImageCaching.html">ImageCaching</a></code></td>
<td>Store image into memory cache</td>
</tr>
</tbody></table>

<p>All those types come together the way you expect:</p>

<ol>
<li><code><a href="Classes/ImagePipeline.html">ImagePipeline</a></code> checks if the image is in memory cache (<code><a href="Protocols/ImageCaching.html">ImageCaching</a></code>). Returns immediately if finds it.</li>
<li><code><a href="Classes/ImagePipeline.html">ImagePipeline</a></code> uses underlying data loader (<code><a href="Protocols/DataLoading.html">DataLoading</a></code>) to fetch (or return cached) image data.</li>
<li>When the image data is loaded it gets decoded (<code><a href="Protocols/ImageDecoding.html">ImageDecoding</a></code>) creating an image object.</li>
<li>The image is then processed (<code><a href="Protocols/ImageProcessing.html">ImageProcessing</a></code>).</li>
<li><code><a href="Classes/ImagePipeline.html">ImagePipeline</a></code> stores the processed image in the memory cache (<code><a href="Protocols/ImageCaching.html">ImageCaching</a></code>).</li>
</ol>

<p>Nuke is fully asynchronous (non-blocking). Each stage is executed on a separate queue tailored specifically for it. Let&rsquo;s dive into each of those stages.</p>
<h3 id='data-loading-and-caching' class='heading'>Data Loading and Caching</h3>

<p>A built-in <code><a href="Classes/DataLoader.html">DataLoader</a></code> class implements <code><a href="Protocols/DataLoading.html">DataLoading</a></code> protocol and uses <a href="https://developer.apple.com/reference/foundation/nsurlsession"><code>Foundation.URLSession</code></a> to load image data. The data is cached on disk using a <a href="https://developer.apple.com/reference/foundation/urlcache"><code>Foundation.URLCache</code></a> instance, which by default is initialized with a memory capacity of 0 MB (Nuke stores images in memory, not image data) and a disk capacity of 150 MB.</p>

<p>The <code>URLSession</code> class natively supports the <code>data</code>, <code>file</code>, <code>ftp</code>, <code>http</code>, and <code>https</code> URL schemes. Image pipeline can be used with any of those schemes as well.</p>

<blockquote>
<p>See <a href="https://kean.github.io/post/image-caching">Image Caching Guide</a> to learn more about image caching</p>

<p>See <a href="https://github.com/kean/Nuke/blob/master/Documentation/Guides/Third%20Party%20Libraries.md#using-other-caching-libraries">Third Party Libraries</a> guide to learn how to use a custom data loader or cache</p>
</blockquote>

<p>Most developers either implement their own networking layer or use a third-party framework. Nuke supports both of those workflows. You can integrate your custom networking layer by implementing <code><a href="Protocols/DataLoading.html">DataLoading</a></code> protocol.</p>

<blockquote>
<p>See <a href="https://github.com/kean/Nuke-Alamofire-Plugin">Alamofire Plugin</a> that implements <code><a href="Protocols/DataLoading.html">DataLoading</a></code> protocol using <a href="https://github.com/Alamofire/Alamofire">Alamofire</a> framework</p>
</blockquote>
<h3 id='memory-cache' class='heading'>Memory Cache</h3>

<p>Processed images which are ready to be displayed are stored in a fast in-memory cache (<code><a href="Classes/ImageCache.html">ImageCache</a></code>). It uses <a href="https://en.wikipedia.org/wiki/Cache_algorithms#Examples">LRU (least recently used)</a> replacement algorithm and has a limit which prevents it from using more than ~20% of available RAM. As a good citizen, <code><a href="Classes/ImageCache.html">ImageCache</a></code> automatically evicts images on memory warnings and removes most of the images when the application enters background.</p>
<h3 id='resumable-downloads' class='heading'>Resumable Downloads</h3>

<p>If the data task is terminated (either because of a failure or a cancellation) and the image was partially loaded, the next load will resume where it was left off. </p>

<p>Resumable downloads require server to support <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Range_requests">HTTP Range Requests</a>. Nuke supports both validators (<code>ETag</code> and <code>Last-Modified</code>). The resumable downloads are enabled by default.</p>

<blockquote>
<p>By default resumable data is stored in an efficient memory cache. Future versions might include more customization.</p>
</blockquote>
<h3 id='request-dedupication' class='heading'>Request Dedupication</h3>

<p>By default <code><a href="Classes/ImagePipeline.html">ImagePipeline</a></code> combines the requests with the same <code>loadKey</code> into a single task. The task&rsquo;s priority is set to the highest priority of registered requests and gets updated when requests are added or removed to the task. The task only gets cancelled when all the registered requests are.</p>

<blockquote>
<p>Deduplication can be disabled using <code><a href="Classes/ImagePipeline/Configuration.html">ImagePipeline.Configuration</a></code>.</p>
</blockquote>

<p><a name="h_performance"></a></p>
<h1 id='performance' class='heading'>Performance</h1>

<p>Performance is one of the key differentiating factors for Nuke. There are four key components of its performance:</p>
<h3 id='main-thread-performance' class='heading'>Main-Thread Performance</h3>

<p>The framework has been tuned to do very little work on the main thread. There are a number of optimizations techniques that were used to achieve that including: reducing number of allocations, reducing dynamic dispatch, backing some structs by reference typed storage to reduce ARC overhead, etc.</p>
<h3 id='robustness-under-stress' class='heading'>Robustness Under Stress</h3>

<p>A common use case is to dynamically start and cancel requests for a collection view full of images when scrolling at a high speed. There are a number of components that ensure robustness in those kinds of scenarios:</p>

<ul>
<li><code><a href="Classes/ImagePipeline.html">ImagePipeline</a></code> schedules each of its stages on a dedicated queue. Each queue limits the number of concurrent tasks. This way we don&rsquo;t use too much system resources at any given moment and each stage doesn&rsquo;t block the other. For example, if the image doesn&rsquo;t require processing, it doesn&rsquo;t go through the processing queue.</li>
<li>Under stress <code><a href="Classes/ImagePipeline.html">ImagePipeline</a></code> will rate limit the requests to prevent trashing of the underlying systems (e.g. <code>URLSession</code>).</li>
</ul>
<h3 id='memory-usage' class='heading'>Memory Usage</h3>

<ul>
<li>Nuke tries to free memory as early as possible.</li>
<li>Memory cache uses <a href="https://en.wikipedia.org/wiki/Cache_algorithms#Examples">LRU (least recently used)</a> replacement algorithm. It has a limit which prevents it from using more than ~20% of available RAM. As a good citizen, <code><a href="Classes/ImageCache.html">ImageCache</a></code> automatically evicts images on memory warnings and removes most of the images when the application enters background.</li>
</ul>
<h3 id='performance-metrics-beta' class='heading'>Performance Metrics (Beta)</h3>

<p>When optimizing performance, it&rsquo;s important to measure. Nuke collects detailed performance metrics during the execution of each image task:</p>
<pre class="highlight swift"><code><span class="kt">ImagePipeline</span><span class="o">.</span><span class="n">shared</span><span class="o">.</span><span class="n">didFinishCollectingMetrics</span> <span class="o">=</span> <span class="p">{</span> <span class="n">task</span><span class="p">,</span> <span class="n">metrics</span> <span class="k">in</span>
    <span class="nf">print</span><span class="p">(</span><span class="n">metrics</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>

<p><img src="https://user-images.githubusercontent.com/1567433/39193766-8dfd81b2-47dc-11e8-86b3-f3f69dc73d3a.png" alt="timeline"></p>
<pre class="highlight plaintext"><code>(lldb) po metrics

Task Information {
    Task ID - 1
    Duration - 22:35:16.123 – 22:35:16.475 (0.352s)
    Was Cancelled - false
    Is Memory Cache Hit - false
    Was Subscribed To Existing Session - false
}
Session Information {
    Session ID - 1
    Total Duration - 0.351s
    Was Cancelled - false
}
Timeline {
    22:35:16.124 – 22:35:16.475 (0.351s) - Total
    ------------------------------------
    nil – nil (nil)                      - Check Disk Cache
    22:35:16.131 – 22:35:16.410 (0.278s) - Load Data
    22:35:16.410 – 22:35:16.468 (0.057s) - Decode
    22:35:16.469 – 22:35:16.474 (0.005s) - Process
}
Resumable Data {
    Was Resumed - nil
    Resumable Data Count - nil
    Server Confirmed Resume - nil
}
</code></pre>

<p><a name="h_plugins"></a></p>
<h1 id='extensions' class='heading'>Extensions</h1>

<p>There are a variety extensions available for Nuke some of which are built by the community.</p>

<table><thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead><tbody>
<tr>
<td><a href="https://github.com/kean/RxNuke"><strong>RxNuke</strong></a></td>
<td><a href="https://github.com/ReactiveX/RxSwift">RxSwift</a> extensions for Nuke with examples of common use cases solved by Rx</td>
</tr>
<tr>
<td><a href="https://github.com/kean/Nuke-Alamofire-Plugin"><strong>Alamofire</strong></a></td>
<td>Replace networking layer with <a href="https://github.com/Alamofire/Alamofire">Alamofire</a> and combine the power of both frameworks</td>
</tr>
<tr>
<td><a href="https://github.com/ryokosuge/Nuke-WebP-Plugin"><strong>WebP</strong></a></td>
<td><strong>[Community]</strong> <a href="https://developers.google.com/speed/webp/">WebP</a> support, built by <a href="https://github.com/ryokosuge">Ryo Kosuge</a></td>
</tr>
<tr>
<td><a href="https://github.com/kean/Nuke-Gifu-Plugin"><strong>Gifu</strong></a></td>
<td>Use <a href="https://github.com/kaishin/Gifu">Gifu</a> to load and display animated GIFs</td>
</tr>
<tr>
<td><a href="https://github.com/kean/Nuke-AnimatedImage-Plugin"><strong>FLAnimatedImage</strong></a></td>
<td>Use <a href="https://github.com/Flipboard/FLAnimatedImage">FLAnimatedImage</a> to load and display <a href="(https://www.youtube.com/watch?v=fEJqQMJrET4)">animated GIFs</a></td>
</tr>
</tbody></table>

<p><a name="h_requirements"></a></p>
<h1 id='minimum-requirements' class='heading'>Minimum Requirements</h1>

<ul>
<li>iOS 9.0 / watchOS 2.0 / macOS 10.10 / tvOS 9.0</li>
<li>Xcode 9.2</li>
<li>Swift 4.0</li>
</ul>
<h1 id='license' class='heading'>License</h1>

<p>Nuke is available under the MIT license. See the LICENSE file for more info.</p>

          </section>
        </section>
        <section id="footer">
          <p>&copy; 2018 <a class="link" href="https://github.com/kean" target="_blank" rel="external">kean</a>. All rights reserved. (Last updated: 2018-05-10)</p>
          <p>Generated by <a class="link" href="https://github.com/realm/jazzy" target="_blank" rel="external">jazzy ♪♫ v0.9.3</a>, a <a class="link" href="https://realm.io" target="_blank" rel="external">Realm</a> project.</p>
        </section>
      </article>
    </div>
  </body>
</div>
</html>
