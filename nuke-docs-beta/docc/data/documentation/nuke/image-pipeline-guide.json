{"seeAlsoSections":[{"title":"Guides","identifiers":["doc:\/\/com.github.kean.Nuke\/documentation\/Nuke\/performance","doc:\/\/com.github.kean.Nuke\/documentation\/Nuke\/image-formats-guide"],"generated":true}],"schemaVersion":{"major":0,"minor":1,"patch":0},"sections":[],"primaryContentSections":[{"kind":"content","content":[{"anchor":"Nuke.loadImage()","level":2,"type":"heading","text":"Nuke.loadImage()"},{"type":"paragraph","inlineContent":[{"type":"text","text":"This method loads an image with the given request and displays it in the view."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Before loading a new image, it prepares the view for reuse by canceling any outstanding requests and removing a previously displayed image."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"If the image is in the memory cache, it is displayed immediately with no animations. If not, it loads the image using an image pipeline. While it is loading, a "},{"type":"codeVoice","code":"placeholder"},{"type":"text","text":" is displayed. When the request completes, Nuke displays the image (or "},{"type":"codeVoice","code":"failureImage"},{"type":"text","text":" in case of an error) with the provided animation."}]},{"anchor":"ImagePipeline.loadImage()","level":2,"type":"heading","text":"ImagePipeline.loadImage()"},{"type":"paragraph","inlineContent":[{"type":"text","text":"This section describes the steps that the pipeline performs when getting an image ready. As a visual aid, use the "},{"type":"reference","isActive":true,"identifier":"https:\/\/github.com\/kean\/Nuke\/blob\/10.0.0\/Documentation\/Assets\/image-pipeline.svg"},{"type":"text","text":" (the data cache part does not yet reflect all changes from Nuke 9)."}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Check if the requested image is in the memory cache."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Check if the processed image data is in the disk cache (assuming disk cache for processed images is enabled. If yes, the iimage is decoded, decompressed, stored in the memory cache, and is delivered to the client."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Check if the original image data is in the disk cache. If yes, it repeats the same steps from the previous point, but this time, it also applies the processors."}]}]}]},{"type":"aside","style":"important","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"The disk cache described in steps 2 and 3 is disabled by default. The pipeline relies on the HTTP-compliant disk cache on a "},{"type":"codeVoice","code":"URLSession"},{"type":"text","text":" level. To learn how to enable the disk cache, see “Aggressive LRU Disk Cache”."}]}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"If all caches are empty, load the image data. If any resumable data was left from a previous equivalent request, use it. Otherwise, start fresh. When the data is loaded, prepare the image for display as in the pervious steps."}]}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Now that you saw a high-level overview, let’s dive into more detail."}]},{"anchor":"Data-Loading-and-Caching","level":3,"type":"heading","text":"Data Loading and Caching"},{"type":"paragraph","inlineContent":[{"type":"reference","isActive":true,"identifier":"doc:\/\/com.github.kean.Nuke\/documentation\/Nuke\/DataLoader"},{"type":"text","text":" uses "},{"type":"reference","isActive":true,"identifier":"https:\/\/developer.apple.com\/reference\/foundation\/nsurlsession"},{"type":"text","text":" to load image data. The data is cached on disk using "},{"type":"reference","isActive":true,"identifier":"https:\/\/developer.apple.com\/reference\/foundation\/urlcache"},{"type":"text","text":", which by default is initialized with a memory capacity of 0 MB (Nuke only stores processed images in memory) and disk capacity of 150 MB."}]},{"type":"aside","style":"tip","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"See "},{"type":"reference","isActive":true,"identifier":"https:\/\/kean.blog\/post\/image-caching"},{"type":"text","text":" to learn more about HTTP cache. To learn more about caching in Nuke and how to configure it, see "},{"type":"reference","isActive":true,"identifier":"\/nuke\/guides\/caching"},{"type":"text","text":"."}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"URLSession"},{"type":"text","text":" class natively supports the following URL schemes: "},{"type":"codeVoice","code":"data"},{"type":"text","text":", "},{"type":"codeVoice","code":"file"},{"type":"text","text":", "},{"type":"codeVoice","code":"ftp"},{"type":"text","text":", "},{"type":"codeVoice","code":"http"},{"type":"text","text":", and "},{"type":"codeVoice","code":"https"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The default "},{"type":"reference","isActive":true,"identifier":"doc:\/\/com.github.kean.Nuke\/documentation\/Nuke\/DataLoader"},{"type":"text","text":" works great for most situation, but if you need to provide a custom networking layer, you can using a "},{"type":"reference","isActive":true,"identifier":"doc:\/\/com.github.kean.Nuke\/documentation\/Nuke\/DataLoading"},{"type":"text","text":" protocol. See "},{"type":"reference","isActive":true,"identifier":"\/nuke\/guides\/third-party-libraries"},{"type":"text","text":" guide to learn more about. See also, "},{"type":"reference","isActive":true,"identifier":"https:\/\/github.com\/kean\/Nuke-Alamofire-Plugin"},{"type":"text","text":"."}]},{"anchor":"Resumable-Downloads","level":2,"type":"heading","text":"Resumable Downloads"},{"type":"paragraph","inlineContent":[{"type":"text","text":"If the data task is terminated when the image is partially loaded (either because of a failure or a cancellation), the next load will resume where the previous left off. Resumable downloads require the server to support "},{"type":"reference","isActive":true,"identifier":"https:\/\/developer.mozilla.org\/en-US\/docs\/Web\/HTTP\/Range_requests"},{"type":"text","text":". Nuke supports both validators: "},{"type":"codeVoice","code":"ETag"},{"type":"text","text":" and "},{"type":"codeVoice","code":"Last-Modified"},{"type":"text","text":". Resumable downloads are enabled by default. You can learn more in "},{"type":"reference","isActive":true,"identifier":"\/post\/resumable-downloads"},{"type":"text","text":"."}]},{"anchor":"Memory-Cache","level":2,"type":"heading","text":"Memory Cache"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The processed images are stored in a fast in-memory cache ("},{"type":"reference","isActive":true,"identifier":"doc:\/\/com.github.kean.Nuke\/documentation\/Nuke\/ImageCache"},{"type":"text","text":"). It uses "},{"type":"reference","isActive":true,"identifier":"https:\/\/en.wikipedia.org\/wiki\/Cache_algorithms#Examples"},{"type":"text","text":" replacement algorithm and has a limit of ~20% of available RAM. "},{"type":"reference","isActive":true,"identifier":"doc:\/\/com.github.kean.Nuke\/documentation\/Nuke\/ImageCache"},{"type":"text","text":" automatically evicts images on memory warnings and removes a portion of its contents when the application enters background mode."}]},{"anchor":"Coalescing","level":2,"type":"heading","text":"Coalescing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The pipeline avoids doing any duplicated work when loading images. For example, let’s take these two requests:"}]},{"type":"codeListing","syntax":"swift","code":["let url = URL(string: \"http:\/\/example.com\/image\")","pipeline.loadImage(with: ImageRequest(url: url, processors: [","    ImageProcessor.Resize(size: CGSize(width: 44, height: 44)),","    ImageProcessor.GaussianBlur(radius: 8)","]))","pipeline.loadImage(with: ImageRequest(url: url, processors: [","    ImageProcessor.Resize(size: CGSize(width: 44, height: 44))","]))"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Nuke will load the data only once, resize the image once and blur it also only once. There is no duplicated work done. The work only gets canceled when all the registered requests are, and the priority is based on the highest priority of the registered requests."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Coalescing can be disabled using "},{"type":"reference","isActive":true,"identifier":"doc:\/\/com.github.kean.Nuke\/documentation\/Nuke\/ImagePipeline\/Configuration-swift.struct\/isTaskCoalescingEnabled"},{"type":"text","text":" configuration option."}]},{"anchor":"Decompression","level":2,"type":"heading","text":"Decompression"},{"type":"paragraph","inlineContent":[{"type":"text","text":"When you instantiate "},{"type":"codeVoice","code":"UIImage"},{"type":"text","text":" with "},{"type":"codeVoice","code":"Data"},{"type":"text","text":", the data can be in a compressed format like "},{"type":"codeVoice","code":"JPEG"},{"type":"text","text":". "},{"type":"codeVoice","code":"UIImage"},{"type":"text","text":" does "},{"type":"emphasis","inlineContent":[{"type":"text","text":"not"}]},{"type":"text","text":" eagerly decompress this data until you display it. It leads to performance issues like scroll view stuttering. To avoid it, Nuke automatically decompresses the data in the background. Decompression only runs if needed; it won’t run for already processed images."}]},{"type":"aside","style":"tip","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"See "},{"type":"reference","isActive":true,"identifier":"https:\/\/developer.apple.com\/videos\/play\/wwdc2018\/219"},{"type":"text","text":" to learn more about image decoding and downsampling."}]}]},{"anchor":"Progressive-Decoding","level":2,"type":"heading","text":"Progressive Decoding"},{"type":"paragraph","inlineContent":[{"type":"text","text":"If progressive decoding is enabled, the pipeline attempts to produce a preview of any image every time a new chunk of data is loaded. See it in action in the "},{"type":"reference","isActive":true,"identifier":"https:\/\/github.com\/kean\/NukeDemo"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"When the pipeline downloads the first chunk of data, it creates an instance of a decoder used for the entire image loading session. When the new chunks are loaded, the pipeline passes them to the decoder. The decoder can either produce a preview or return nil if not enough data is downloaded."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Every image preview goes through the same processing and decompression phases that the final images do. The main difference is the introduction of backpressure. If one of the stages can’t process the input fast enough, then the pipeline waits until the current operation is finished, and only then starts the next one. When the data is fully downloaded, all outstanding progressive operations are canceled to save processing time."}]},{"anchor":"Performance","level":2,"type":"heading","text":"Performance"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Nuke is tuned to have at little overhead as possible. It uses multiple optimization techniques to achieve that: reducing the number of allocations, reducing dynamic dispatch, CoW, etc. There is virtually nothing left in Nuke that could be changed to improve main thread performance."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"If you measure just Nuke code, it takes about "},{"type":"strong","inlineContent":[{"type":"text","text":"0.004 ms"}]},{"type":"text","text":" (4 "},{"type":"emphasis","inlineContent":[{"type":"text","text":"micro"}]},{"type":"text","text":"seconds) on the main thread per request and about "},{"type":"strong","inlineContent":[{"type":"text","text":"0.03 ms"}]},{"type":"text","text":" (30 microseconds) overall, as measured on iPhone 11 Pro using Nuke 10.0."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Nuke is fully asynchronous and performs well under stress. "},{"type":"codeVoice","code":"ImagePipeline"},{"type":"text","text":" schedules its operations on dedicated queues. A queue limits the number of concurrent tasks, manages the request priorities, cancels the work when needed. Under extreme load, "},{"type":"codeVoice","code":"ImagePipeline"},{"type":"text","text":" will also rate-limit requests to prevent saturation of the underlying systems."}]},{"type":"aside","style":"tip","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"To learn more about Nuke performance, see "},{"type":"reference","isActive":true,"identifier":"https:\/\/kean.blog\/post\/nuke-9"},{"type":"text","text":"."}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"If you want to see how the system behaves, how long each operation takes, and how many are performed in parallel, enable the "},{"type":"codeVoice","code":"isSignpostLoggingEnabled"},{"type":"text","text":" option and use the "},{"type":"codeVoice","code":"os_signpost"},{"type":"text","text":" Instrument. For more information see "},{"type":"reference","isActive":true,"identifier":"https:\/\/developer.apple.com\/documentation\/os\/logging"},{"type":"text","text":" and "},{"type":"reference","isActive":true,"identifier":"https:\/\/developer.apple.com\/videos\/play\/wwdc2018\/405\/"},{"type":"text","text":"."}]},{"anchor":"Benchmarks","level":2,"type":"heading","text":"Benchmarks"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Image loading frameworks are often used in table and collection views with a large number of cells. They must perform well to achieve buttery smooth scrolling."}]},{"type":"aside","style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Please keep in mind that this performance test ("},{"type":"reference","isActive":true,"identifier":"https:\/\/github.com\/kean\/Image-Frameworks-Benchmark"},{"type":"text","text":") makes for a very nice-looking chart, but in practice, the difference between Nuke and say SDWebImage will be that dramatic. Unless your app drops frames on a table or a collection view rendering, there is no real reason to switch."}]}]},{"type":"paragraph","inlineContent":[{"type":"image","identifier":"bench-01"},{"type":"text","text":" "},{"type":"image","identifier":"bench-02"}]},{"anchor":"Tasks","level":2,"type":"heading","text":"Tasks"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Nuke has an incredible number of performance "},{"overridingTitleInlineContent":[{"type":"text","text":"features"}],"isActive":true,"type":"reference","identifier":"https:\/\/kean.blog\/post\/nuke-9","overridingTitle":"features"},{"type":"text","text":": progressive decoding, prioritization, coalescing of tasks, cooperative cancellation, parallel processing, backpressure, prefetching. It forces Nuke to be massively concurrent. The actor model is just part of the solution. To manage individual image requests, it needed a structured approach for managing async tasks."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The solution is "},{"type":"reference","isActive":true,"identifier":"https:\/\/github.com\/kean\/Nuke\/blob\/93c187ab98ab02f8c891d1fa40ffe92a1591f524\/Sources\/Tasks\/Task.swift#L18"},{"type":"text","text":", which is a part of the internal infrastructure. When you request an image, Nuke creates a dependency tree with multiple tasks. When a similar image request arrives (e.g. the same URL, but different processors), an existing subtree can serve as a dependency of another task."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Nuke supports progressive decoding and task design reflects that. Tasks send events "},{"type":"emphasis","inlineContent":[{"type":"text","text":"upstream"}]},{"type":"text","text":": data chunks, image scans, progress updates, errors. Tasks send priority updates and cancellation requests "},{"type":"emphasis","inlineContent":[{"type":"text","text":"downstream"}]},{"type":"text","text":". This design is inspired by reactive programming, but is optimized for Nuke. Tasks are much simpler and faster than a typical generalized reactive programming implementation. The complete implementation takes just 237 lines."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Some tasks implement "},{"type":"emphasis","inlineContent":[{"type":"text","text":"backpressure"}]},{"type":"text","text":". For example, if you are fetching a progressive JPEG and have an expensive processor, such as blur, the processing task will only produce processed images as fast as it can, skipping the scans it has no capacity to handle."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"All of the tasks are synchronozied on a single serial dispatch queue. This a simple and reliable way to achieve performance and thread safety."}]},{"type":"aside","style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"To learn more about how Nuke manages concurrency, see "},{"type":"reference","isActive":true,"identifier":"https:\/\/kean.blog\/post\/concurrency"},{"type":"text","text":"."}]}]}]}],"variants":[{"paths":["\/documentation\/nuke\/image-pipeline-guide"],"traits":[{"interfaceLanguage":"swift"}]}],"identifier":{"url":"doc:\/\/com.github.kean.Nuke\/documentation\/Nuke\/image-pipeline-guide","interfaceLanguage":"swift"},"abstract":[{"type":"text","text":"This guide describes in detail what happens under the hood when you call "},{"type":"reference","isActive":true,"identifier":"doc:\/\/com.github.kean.Nuke\/documentation\/Nuke\/loadImage(with:options:into:progress:completion:)"},{"type":"text","text":" method."}],"kind":"article","metadata":{"roleHeading":"Article","title":"Image Pipeline Guide","role":"article","modules":[{"name":"Nuke"}]},"hierarchy":{"paths":[["doc:\/\/com.github.kean.Nuke\/documentation\/Nuke"]]},"documentVersion":0,"references":{"bench-02":{"alt":null,"type":"image","identifier":"bench-02","variants":[{"url":"\/images\/bench-02.png","size":{"width":1400,"height":720},"traits":["1x","light"]}]},"https://developer.apple.com/reference/foundation/urlcache":{"title":"URLCache","titleInlineContent":[{"type":"codeVoice","code":"URLCache"}],"type":"link","identifier":"https:\/\/developer.apple.com\/reference\/foundation\/urlcache","url":"https:\/\/developer.apple.com\/reference\/foundation\/urlcache"},"doc://com.github.kean.Nuke/documentation/Nuke/image-formats-guide":{"role":"article","title":"Image Formats","abstract":[{"type":"text","text":"Nuke has built-in support for basic image formats like "},{"type":"codeVoice","code":"jpeg"},{"type":"text","text":", "},{"type":"codeVoice","code":"png"},{"type":"text","text":", and "},{"type":"codeVoice","code":"heif"},{"type":"text","text":". It also has the infrastructure for supporting a variety of custom image formats."}],"identifier":"doc:\/\/com.github.kean.Nuke\/documentation\/Nuke\/image-formats-guide","kind":"article","type":"topic","url":"\/documentation\/nuke\/image-formats-guide"},"bench-01":{"alt":null,"type":"image","identifier":"bench-01","variants":[{"url":"\/images\/bench-01.png","size":{"width":1400,"height":720},"traits":["1x","light"]}]},"doc://com.github.kean.Nuke/documentation/Nuke":{"role":"collection","title":"Nuke","abstract":[{"type":"text","text":"Welcome to the documentation for Nuke, an image loading system for Apple platforms."}],"identifier":"doc:\/\/com.github.kean.Nuke\/documentation\/Nuke","kind":"symbol","type":"topic","url":"\/documentation\/nuke"},"https://github.com/kean/Nuke/blob/10.0.0/Documentation/Assets/image-pipeline.svg":{"title":"block diagram","titleInlineContent":[{"type":"text","text":"block diagram"}],"type":"link","identifier":"https:\/\/github.com\/kean\/Nuke\/blob\/10.0.0\/Documentation\/Assets\/image-pipeline.svg","url":"https:\/\/github.com\/kean\/Nuke\/blob\/10.0.0\/Documentation\/Assets\/image-pipeline.svg"},"https://developer.apple.com/videos/play/wwdc2018/219":{"title":"Image and Graphics Best Practices","titleInlineContent":[{"type":"text","text":"Image and Graphics Best Practices"}],"type":"link","identifier":"https:\/\/developer.apple.com\/videos\/play\/wwdc2018\/219","url":"https:\/\/developer.apple.com\/videos\/play\/wwdc2018\/219"},"doc://com.github.kean.Nuke/documentation/Nuke/loadImage(with:options:into:progress:completion:)":{"role":"symbol","title":"loadImage(with:options:into:progress:completion:)","fragments":[{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"kind":"identifier","text":"loadImage"},{"kind":"text","text":"("},{"kind":"externalParam","text":"with"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"ImageRequestConvertible","preciseIdentifier":"s:4Nuke23ImageRequestConvertibleP"},{"kind":"text","text":"?, "},{"kind":"externalParam","text":"options"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"ImageLoadingOptions","preciseIdentifier":"s:4Nuke19ImageLoadingOptionsV"},{"kind":"text","text":", "},{"kind":"externalParam","text":"into"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"ImageDisplayingView","preciseIdentifier":"s:4Nuke19ImageDisplayingViewa"},{"kind":"text","text":", "},{"kind":"externalParam","text":"progress"},{"kind":"text","text":": (("},{"kind":"typeIdentifier","text":"ImageResponse","preciseIdentifier":"s:4Nuke13ImageResponseV"},{"kind":"text","text":"?, "},{"kind":"typeIdentifier","text":"Int64","preciseIdentifier":"s:s5Int64V"},{"kind":"text","text":", "},{"kind":"typeIdentifier","text":"Int64","preciseIdentifier":"s:s5Int64V"},{"kind":"text","text":") -> "},{"kind":"typeIdentifier","text":"Void","preciseIdentifier":"s:s4Voida"},{"kind":"text","text":")?, "},{"kind":"externalParam","text":"completion"},{"kind":"text","text":": (("},{"kind":"typeIdentifier","text":"Result","preciseIdentifier":"s:s6ResultO"},{"kind":"text","text":"<"},{"kind":"typeIdentifier","text":"ImageResponse","preciseIdentifier":"s:4Nuke13ImageResponseV"},{"kind":"text","text":", "},{"kind":"typeIdentifier","text":"ImagePipeline","preciseIdentifier":"s:4Nuke13ImagePipelineC"},{"kind":"text","text":"."},{"kind":"typeIdentifier","text":"Error","preciseIdentifier":"s:4Nuke13ImagePipelineC5ErrorO"},{"kind":"text","text":">) -> "},{"kind":"typeIdentifier","text":"Void","preciseIdentifier":"s:s4Voida"},{"kind":"text","text":")?) -> "},{"kind":"typeIdentifier","text":"ImageTask","preciseIdentifier":"s:4Nuke9ImageTaskC"},{"kind":"text","text":"?"}],"abstract":[{"type":"text","text":"Loads an image with the given request and displays it in the view."}],"identifier":"doc:\/\/com.github.kean.Nuke\/documentation\/Nuke\/loadImage(with:options:into:progress:completion:)","kind":"symbol","type":"topic","url":"\/documentation\/nuke\/loadimage(with:options:into:progress:completion:)"},"doc://com.github.kean.Nuke/documentation/Nuke/ImageCache":{"role":"symbol","title":"ImageCache","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"ImageCache"}],"abstract":[{"type":"text","text":"An LRU memory cache."}],"identifier":"doc:\/\/com.github.kean.Nuke\/documentation\/Nuke\/ImageCache","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"ImageCache"}],"url":"\/documentation\/nuke\/imagecache"},"https://github.com/kean/Image-Frameworks-Benchmark":{"title":"sources","titleInlineContent":[{"type":"text","text":"sources"}],"type":"link","identifier":"https:\/\/github.com\/kean\/Image-Frameworks-Benchmark","url":"https:\/\/github.com\/kean\/Image-Frameworks-Benchmark"},"/nuke/guides/caching":{"title":"Caching","titleInlineContent":[{"type":"text","text":"Caching"}],"type":"link","identifier":"\/nuke\/guides\/caching","url":"\/nuke\/guides\/caching"},"/nuke/guides/third-party-libraries":{"title":"Third Party Libraries","titleInlineContent":[{"type":"text","text":"Third Party Libraries"}],"type":"link","identifier":"\/nuke\/guides\/third-party-libraries","url":"\/nuke\/guides\/third-party-libraries"},"doc://com.github.kean.Nuke/documentation/Nuke/performance":{"role":"article","title":"Performance Guide","abstract":[{"type":"text","text":"Nuke is highly "},{"type":"reference","isActive":true,"identifier":"https:\/\/kean.blog\/post\/concurrency"},{"type":"text","text":" and provides many performance "},{"type":"reference","isActive":true,"identifier":"https:\/\/kean.blog\/post\/nuke-9"},{"type":"text","text":", but it’s ultimately up to your app to decide how to use them."}],"identifier":"doc:\/\/com.github.kean.Nuke\/documentation\/Nuke\/performance","kind":"article","type":"topic","url":"\/documentation\/nuke\/performance"},"/post/resumable-downloads":{"title":"“Resumable Downloads”","titleInlineContent":[{"type":"text","text":"“Resumable Downloads”"}],"type":"link","identifier":"\/post\/resumable-downloads","url":"\/post\/resumable-downloads"},"doc://com.github.kean.Nuke/documentation/Nuke/ImagePipeline/Configuration-swift.struct/isTaskCoalescingEnabled":{"role":"symbol","title":"isTaskCoalescingEnabled","fragments":[{"kind":"keyword","text":"var"},{"kind":"text","text":" "},{"kind":"identifier","text":"isTaskCoalescingEnabled"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"Bool","preciseIdentifier":"s:Sb"}],"abstract":[{"type":"codeVoice","code":"true"},{"type":"text","text":" by default. If "},{"type":"codeVoice","code":"true"},{"type":"text","text":" the pipeline avoids duplicated work when"},{"type":"text","text":" "},{"type":"text","text":"loading images. The work only gets cancelled when all the registered"},{"type":"text","text":" "},{"type":"text","text":"requests are. The pipeline also automatically manages the priority of the"},{"type":"text","text":" "},{"type":"text","text":"deduplicated work."}],"identifier":"doc:\/\/com.github.kean.Nuke\/documentation\/Nuke\/ImagePipeline\/Configuration-swift.struct\/isTaskCoalescingEnabled","kind":"symbol","type":"topic","url":"\/documentation\/nuke\/imagepipeline\/configuration-swift.struct\/istaskcoalescingenabled"},"https://kean.blog/post/concurrency":{"title":"Concurrency in Nuke","titleInlineContent":[{"type":"text","text":"Concurrency in Nuke"}],"type":"link","identifier":"https:\/\/kean.blog\/post\/concurrency","url":"https:\/\/kean.blog\/post\/concurrency"},"https://developer.mozilla.org/en-US/docs/Web/HTTP/Range_requests":{"title":"HTTP Range Requests","titleInlineContent":[{"type":"text","text":"HTTP Range Requests"}],"type":"link","identifier":"https:\/\/developer.mozilla.org\/en-US\/docs\/Web\/HTTP\/Range_requests","url":"https:\/\/developer.mozilla.org\/en-US\/docs\/Web\/HTTP\/Range_requests"},"doc://com.github.kean.Nuke/documentation/Nuke/DataLoading":{"role":"symbol","title":"DataLoading","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"DataLoading"}],"abstract":[{"type":"text","text":"Fetches original image data."}],"identifier":"doc:\/\/com.github.kean.Nuke\/documentation\/Nuke\/DataLoading","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"DataLoading"}],"url":"\/documentation\/nuke\/dataloading"},"https://developer.apple.com/reference/foundation/nsurlsession":{"title":"URLSession","titleInlineContent":[{"type":"codeVoice","code":"URLSession"}],"type":"link","identifier":"https:\/\/developer.apple.com\/reference\/foundation\/nsurlsession","url":"https:\/\/developer.apple.com\/reference\/foundation\/nsurlsession"},"https://github.com/kean/NukeDemo":{"title":"demo project","titleInlineContent":[{"type":"text","text":"demo project"}],"type":"link","identifier":"https:\/\/github.com\/kean\/NukeDemo","url":"https:\/\/github.com\/kean\/NukeDemo"},"https://kean.blog/post/nuke-9":{"title":"“Nuke 9”","titleInlineContent":[{"type":"text","text":"“Nuke 9”"}],"type":"link","identifier":"https:\/\/kean.blog\/post\/nuke-9","url":"https:\/\/kean.blog\/post\/nuke-9"},"https://developer.apple.com/documentation/os/logging":{"title":"Apple Documentation: Logging","titleInlineContent":[{"type":"text","text":"Apple Documentation: Logging"}],"type":"link","identifier":"https:\/\/developer.apple.com\/documentation\/os\/logging","url":"https:\/\/developer.apple.com\/documentation\/os\/logging"},"doc://com.github.kean.Nuke/documentation/Nuke/DataLoader":{"role":"symbol","title":"DataLoader","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"DataLoader"}],"abstract":[{"type":"text","text":"Provides basic networking using "},{"type":"codeVoice","code":"URLSession"},{"type":"text","text":"."}],"identifier":"doc:\/\/com.github.kean.Nuke\/documentation\/Nuke\/DataLoader","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"DataLoader"}],"url":"\/documentation\/nuke\/dataloader"},"https://developer.apple.com/videos/play/wwdc2018/405/":{"title":"WWDC 2018: Measuring Performance Using Logging","titleInlineContent":[{"type":"text","text":"WWDC 2018: Measuring Performance Using Logging"}],"type":"link","identifier":"https:\/\/developer.apple.com\/videos\/play\/wwdc2018\/405\/","url":"https:\/\/developer.apple.com\/videos\/play\/wwdc2018\/405\/"},"https://github.com/kean/Nuke-Alamofire-Plugin":{"title":"Alamofire Plugin","titleInlineContent":[{"type":"text","text":"Alamofire Plugin"}],"type":"link","identifier":"https:\/\/github.com\/kean\/Nuke-Alamofire-Plugin","url":"https:\/\/github.com\/kean\/Nuke-Alamofire-Plugin"},"https://github.com/kean/Nuke/blob/93c187ab98ab02f8c891d1fa40ffe92a1591f524/Sources/Tasks/Task.swift#L18":{"title":"Task","titleInlineContent":[{"type":"codeVoice","code":"Task"}],"type":"link","identifier":"https:\/\/github.com\/kean\/Nuke\/blob\/93c187ab98ab02f8c891d1fa40ffe92a1591f524\/Sources\/Tasks\/Task.swift#L18","url":"https:\/\/github.com\/kean\/Nuke\/blob\/93c187ab98ab02f8c891d1fa40ffe92a1591f524\/Sources\/Tasks\/Task.swift#L18"},"https://en.wikipedia.org/wiki/Cache_algorithms#Examples":{"title":"LRU (least recently used)","titleInlineContent":[{"type":"text","text":"LRU (least recently used)"}],"type":"link","identifier":"https:\/\/en.wikipedia.org\/wiki\/Cache_algorithms#Examples","url":"https:\/\/en.wikipedia.org\/wiki\/Cache_algorithms#Examples"},"https://kean.blog/post/image-caching":{"title":"Image Caching","titleInlineContent":[{"type":"text","text":"Image Caching"}],"type":"link","identifier":"https:\/\/kean.blog\/post\/image-caching","url":"https:\/\/kean.blog\/post\/image-caching"}}}