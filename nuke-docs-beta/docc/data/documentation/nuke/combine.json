{"seeAlsoSections":[{"title":"Advanced","identifiers":["doc:\/\/com.github.kean.Nuke\/documentation\/Nuke\/configuration","doc:\/\/com.github.kean.Nuke\/documentation\/Nuke\/caching","doc:\/\/com.github.kean.Nuke\/documentation\/Nuke\/prefetching","doc:\/\/com.github.kean.Nuke\/documentation\/Nuke\/plugins"],"generated":true}],"schemaVersion":{"major":0,"minor":1,"patch":0},"sections":[],"primaryContentSections":[{"kind":"content","content":[{"anchor":"overview","level":2,"type":"heading","text":"Overview"},{"type":"aside","style":"tip","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"If you need to support earlier iOS versions, check out "},{"type":"reference","isActive":true,"identifier":"https:\/\/github.com\/kean\/RxNuke"},{"type":"text","text":" - RxSwift extensions for Nuke"}]}]},{"anchor":"Image-Publisher","level":2,"type":"heading","text":"Image Publisher"},{"type":"paragraph","inlineContent":[{"type":"text","text":"To create "},{"type":"reference","isActive":true,"identifier":"doc:\/\/com.github.kean.Nuke\/documentation\/Nuke\/ImagePublisher"},{"type":"text","text":", use the following API added to "},{"type":"reference","isActive":true,"identifier":"doc:\/\/com.github.kean.Nuke\/documentation\/Nuke\/ImagePipeline"},{"type":"text","text":":"}]},{"type":"codeListing","syntax":"swift","code":["public extension ImagePipeline {","    func imagePublisher(with request: ImageRequestConvertible) -> ImagePublisher","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"A basic example where we load an image and display the result on success:"}]},{"type":"codeListing","syntax":"swift","code":["cancellable = pipeline.imagePublisher(with: url)","    .sink(receiveCompletion: { _ in \/* Ignore errors *\/ },","          receiveValue: { imageView.image = $0.image })"]},{"anchor":"Displaying-Images","level":2,"type":"heading","text":"Displaying Images"},{"type":"paragraph","inlineContent":[{"type":"text","text":"So you created a custom publisher by combining a couple of operators, how do you use it to display the image? "},{"type":"reference","isActive":true,"identifier":"doc:\/\/com.github.kean.Nuke\/documentation\/Nuke\/FetchImage"},{"type":"text","text":" provides a simple way to display the resuling image."}]},{"type":"codeListing","syntax":"swift","code":["let image = FetchImage()","let publisher = pipeline.imagePublisher(with: \"https:\/\/example.com\/image.jpeg\")","image.load(publisher)"]},{"anchor":"Use-Cases","level":2,"type":"heading","text":"Use Cases"},{"type":"paragraph","inlineContent":[{"type":"text","text":"There are many scenarios in which you can find Combine useful. Here are some of them."}]},{"anchor":"Low-Resolution-to-High","level":3,"type":"heading","text":"Low Resolution to High"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Let’s say you want to show a user a high-resolution image that takes a while to loads. You can show a spinner while the high-resolution image is downloaded, but you can improve the user experience by quickly downloading and displaying a thumbnail."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can implement it using "},{"type":"codeVoice","code":"append"},{"type":"text","text":" operator. This operator results in a serial execution. It starts a thumbnail request, waits until it finishes, and only then starts a request for a high-resolution image."}]},{"type":"codeListing","syntax":"swift","code":["let lowResImage = pipeline.imagePublisher(with: lowResUrl).orEmpty","let highResImage = pipeline.imagePublisher(with: highResUrl).orEmpty","","cancellable = lowResImage.append(highResImage)","    .sink(receiveCompletion: { _ in \/* Ignore errors *\/ },","          receiveValue: { imageView.image = $0.image })"]},{"type":"aside","style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"orEmpty"},{"type":"text","text":" is a custom property that catches the errors and immediately completes the publishes instead."}]}]},{"type":"codeListing","syntax":"swift","code":["public extension Publisher {","    var orEmpty: AnyPublisher<Output, Never> {","        catch { _ in Empty<Output, Never>() }.eraseToAnyPublisher()","    }","}"]},{"anchor":"Load-the-First-Available","level":3,"type":"heading","text":"Load the First Available"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Let’s say you have multiple URLs for the same image. For example, you uploaded the image from the camera to the server; you have the image stored locally. When you display this image, it would be beneficial to first load the local URL, and if that fails, try to download from the network."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This use case is very similar to "},{"type":"reference","isActive":true,"identifier":"#going-from-low-to-high-resolution"},{"type":"text","text":", except for the addition of the "},{"type":"codeVoice","code":"first()"},{"type":"text","text":" operator that stops the execution when the first value is received."}]},{"type":"codeListing","syntax":"swift","code":["let localImage = pipeline.imagePublisher(with: localUrl).orEmpty","let networkImage = pipeline.imagePublisher(with: networkUrl).orEmpty","","cancellable = localImage.append(networkImage)","    .first()","    .sink(receiveCompletion: { _ in \/* Ignore errors *\/ },","          receiveValue: { imageView.image = $0.image })"]},{"anchor":"Load-Multiple-Images","level":3,"type":"heading","text":"Load Multiple Images"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Let’s say you want to load two icons for a button, one icon for a "},{"type":"codeVoice","code":".normal"},{"type":"text","text":" state, and one for a "},{"type":"codeVoice","code":".selected"},{"type":"text","text":" state. You want to update the button, only when both icons are fully loaded. This can be achieved using a "},{"type":"codeVoice","code":"combine"},{"type":"text","text":" operator."}]},{"type":"codeListing","syntax":"swift","code":["let iconImage = pipeline.imagePublisher(with: iconUrl)","let iconSelectedImage = pipeline.imagePublisher(with: iconSelectedUrl)","","cancellable = iconImage.combineLatest(iconSelectedImage)","    .sink(receiveCompletion: { _ in \/* Ignore errors *\/ },","          receiveValue: { icon, iconSelected in","            button.isHidden = false","            button.setImage(icon.image, for: .normal)","            button.setImage(iconSelected.image, for: .selected)","         })"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Notice there is no "},{"type":"codeVoice","code":"orEmpty"},{"type":"text","text":" in this example since we want both requests to succeed."}]},{"anchor":"Validate-Stale-Image","level":3,"type":"heading","text":"Validate Stale Image"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Let’s say you want to show the user a stale image stored in disk cache ("},{"type":"codeVoice","code":"Foundation.URLCache"},{"type":"text","text":") while you go to the server to validate if the image is still fresh. It can be implemented using the same "},{"type":"codeVoice","code":"append"},{"type":"text","text":" operator that we covered "},{"overridingTitleInlineContent":[{"type":"text","text":"previously"}],"isActive":true,"type":"reference","identifier":"#going-from-low-to-high-resolution","overridingTitle":"previously"},{"type":"text","text":"."}]},{"type":"codeListing","syntax":"swift","code":["let cacheRequest = URLRequest(url: url, cachePolicy: .returnCacheDataDontLoad)","let networkRequest = URLRequest(url: url, cachePolicy: .useProtocolCachePolicy)","","let cachedImage = pipeline.imagePublisher(with: ImageRequest(urlRequest: cacheRequest)).orEmpty","let networkImage = pipeline.imagePublisher(with: ImageRequest(urlRequest: networkRequest)).orEmpty","","cancellable = cachedImage.append(networkImage)","    .sink(receiveCompletion: { _ in \/* Ignore errors *\/ },","          receiveValue: { imageView.image = $0.image })"]},{"type":"aside","style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"See "},{"type":"reference","isActive":true,"identifier":"https:\/\/kean.blog\/post\/image-caching"},{"type":"text","text":" to learn more about HTTP cache."},{"type":"text","text":" "},{"type":"text","text":"{:.info}"}]}]},{"anchor":"Low-Data-Mode","level":3,"type":"heading","text":"Low Data Mode"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Starting with iOS 13, the iOS users can enable “Low Data Mode” in system settings. One of the ways the apps can handle it is to use resources that take less network bandwidth. Combine makes it easy to implement."}]},{"type":"codeListing","syntax":"swift","code":["\/\/ Create the original image request and prevent it from going through","\/\/ when \"Low Data Mode\" is enabled in the iOS settings.","var urlRequest = URLRequest(url: URL(string: \"https:\/\/example.com\/high-quality.jpeg\")!)","urlRequest.allowsConstrainedNetworkAccess = false","let request = ImageRequest(urlRequest: urlRequest)","","\/\/ Catch the \"constrained\" network error and provide a fallback resource","\/\/ that uses less network bandwidth.","let image = pipeline.imagePublisher(with: request).tryCatch { error -> ImagePublisher in","    guard (error.dataLoadingError as? URLError)?.networkUnavailableReason == .constrained else {","        throw error","    }","    return pipeline.imagePublisher(with: URL(string: \"https:\/\/example.com\/low-quality.jpeg\"))","}","","cancellable = image.sink(receiveCompletion: { result in","    \/\/ Handle error","}, receiveValue: {","    imageView.image = $0.image","})"]},{"type":"aside","style":"tip","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Learn more about Low Data Mode in "},{"type":"reference","isActive":true,"identifier":"https:\/\/developer.apple.com\/videos\/play\/wwdc2019\/712\/"},{"type":"text","text":"."}]}]}]}],"variants":[{"paths":["\/documentation\/nuke\/combine"],"traits":[{"interfaceLanguage":"swift"}]}],"identifier":{"url":"doc:\/\/com.github.kean.Nuke\/documentation\/Nuke\/combine","interfaceLanguage":"swift"},"abstract":[{"type":"reference","isActive":true,"identifier":"doc:\/\/com.github.kean.Nuke\/documentation\/Nuke\/ImagePublisher"},{"type":"text","text":" starts a new "},{"type":"reference","isActive":true,"identifier":"doc:\/\/com.github.kean.Nuke\/documentation\/Nuke\/ImageTask"},{"type":"text","text":" when a subscriber is added and delivers the results to the subscriber. If the requested image is available in the memory cache, the value is delivered immediately. When the subscription is canceled, the task also gets canceled."}],"kind":"article","metadata":{"roleHeading":"Article","title":"Combine","role":"article","modules":[{"name":"Nuke"}]},"hierarchy":{"paths":[["doc:\/\/com.github.kean.Nuke\/documentation\/Nuke"]]},"documentVersion":0,"references":{"#going-from-low-to-high-resolution":{"title":"Going From Low to High Resolution","titleInlineContent":[{"type":"text","text":"Going From Low to High Resolution"}],"type":"link","identifier":"#going-from-low-to-high-resolution","url":"#going-from-low-to-high-resolution"},"doc://com.github.kean.Nuke/documentation/Nuke/caching":{"role":"article","title":"Caching","abstract":[{"type":"text","text":"Nuke has three cache layers that you can configure to precisely match your app needs. The pipeline uses these caches when you request an image. Your app has advanced control over how images are stored and retrieved and direct access to all cache layers."}],"identifier":"doc:\/\/com.github.kean.Nuke\/documentation\/Nuke\/caching","kind":"article","type":"topic","url":"\/documentation\/nuke\/caching"},"https://github.com/kean/RxNuke":{"title":"RxNuke","titleInlineContent":[{"type":"text","text":"RxNuke"}],"type":"link","identifier":"https:\/\/github.com\/kean\/RxNuke","url":"https:\/\/github.com\/kean\/RxNuke"},"doc://com.github.kean.Nuke/documentation/Nuke/prefetching":{"role":"article","title":"Prefetching","abstract":[{"type":"text","text":"Loading data ahead of time in anticipation of its use (prefetching) is a great way to improve user experience. It’s especially effective for images; it can give users an impression that there is no networking and the images are just magically always there."}],"identifier":"doc:\/\/com.github.kean.Nuke\/documentation\/Nuke\/prefetching","kind":"article","type":"topic","url":"\/documentation\/nuke\/prefetching"},"doc://com.github.kean.Nuke/documentation/Nuke/ImageTask":{"role":"symbol","title":"ImageTask","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"ImageTask"}],"abstract":[{"type":"text","text":"A task performed by the "},{"type":"codeVoice","code":"ImagePipeline"},{"type":"text","text":"."}],"identifier":"doc:\/\/com.github.kean.Nuke\/documentation\/Nuke\/ImageTask","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"ImageTask"}],"url":"\/documentation\/nuke\/imagetask"},"doc://com.github.kean.Nuke/documentation/Nuke/plugins":{"role":"article","title":"Plugins","abstract":[{"type":"text","text":"The image pipeline is easy to customize and extend. Check out the following first-class extensions and packages built by the community."}],"identifier":"doc:\/\/com.github.kean.Nuke\/documentation\/Nuke\/plugins","kind":"article","type":"topic","url":"\/documentation\/nuke\/plugins"},"doc://com.github.kean.Nuke/documentation/Nuke/configuration":{"role":"article","title":"Configuration","abstract":[{"type":"text","text":"Nuke virtually unlimited possibilities for customization and most of them are done using "},{"type":"reference","isActive":true,"identifier":"doc:\/\/com.github.kean.Nuke\/documentation\/Nuke\/ImagePipeline\/Configuration-swift.struct"},{"type":"text","text":"."}],"identifier":"doc:\/\/com.github.kean.Nuke\/documentation\/Nuke\/configuration","kind":"article","type":"topic","url":"\/documentation\/nuke\/configuration"},"doc://com.github.kean.Nuke/documentation/Nuke/ImagePublisher":{"role":"symbol","title":"ImagePublisher","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"ImagePublisher"}],"abstract":[{"type":"text","text":"A publisher that starts a new "},{"type":"codeVoice","code":"ImageTask"},{"type":"text","text":" when a subscriber is added."}],"identifier":"doc:\/\/com.github.kean.Nuke\/documentation\/Nuke\/ImagePublisher","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"ImagePublisher"}],"url":"\/documentation\/nuke\/imagepublisher"},"doc://com.github.kean.Nuke/documentation/Nuke":{"role":"collection","title":"Nuke","abstract":[{"type":"text","text":"Welcome to the documentation for Nuke, an image loading system for Apple platforms."}],"identifier":"doc:\/\/com.github.kean.Nuke\/documentation\/Nuke","kind":"symbol","type":"topic","url":"\/documentation\/nuke"},"doc://com.github.kean.Nuke/documentation/Nuke/ImagePipeline":{"role":"symbol","title":"ImagePipeline","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"ImagePipeline"}],"abstract":[{"type":"codeVoice","code":"ImagePipeline"},{"type":"text","text":" is the primary way to load images directly (without a UI)."}],"identifier":"doc:\/\/com.github.kean.Nuke\/documentation\/Nuke\/ImagePipeline","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"ImagePipeline"}],"url":"\/documentation\/nuke\/imagepipeline"},"https://kean.blog/post/image-caching":{"title":"“Image Caching”","titleInlineContent":[{"type":"text","text":"“Image Caching”"}],"type":"link","identifier":"https:\/\/kean.blog\/post\/image-caching","url":"https:\/\/kean.blog\/post\/image-caching"},"doc://com.github.kean.Nuke/documentation/Nuke/FetchImage":{"role":"symbol","title":"FetchImage","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"FetchImage"}],"abstract":[{"type":"text","text":"An observable object that simplifies image loading in SwiftUI."}],"identifier":"doc:\/\/com.github.kean.Nuke\/documentation\/Nuke\/FetchImage","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"FetchImage"}],"url":"\/documentation\/nuke\/fetchimage"},"https://developer.apple.com/videos/play/wwdc2019/712/":{"title":"WWDC2019: Advances in Networking, Part 1","titleInlineContent":[{"type":"text","text":"WWDC2019: Advances in Networking, Part 1"}],"type":"link","identifier":"https:\/\/developer.apple.com\/videos\/play\/wwdc2019\/712\/","url":"https:\/\/developer.apple.com\/videos\/play\/wwdc2019\/712\/"}}}